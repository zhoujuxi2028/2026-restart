# 02 - Python数据结构（39题）

## 涵盖内容
- 底层实现原理：4题
- 列表（List）：12题
- 元组（Tuple）：6题
- 字典（Dict）：10题
- 集合（Set）：7题

---

## 底层实现原理部分

### 第66题：Python对象在内存中的表示

**问题**：Python对象在CPython中是如何在内存中表示的？

**答案**：

#### 1. PyObject基础结构

所有Python对象在CPython中都基于`PyObject`结构：

```python
# CPython内部的C结构（简化版）
typedef struct _object {
    Py_ssize_t ob_refcnt;  # 引用计数
    PyTypeObject *ob_type;  # 对象类型指针
} PyObject;
```

| 字段 | 说明 | 大小 |
|------|------|------|
| `ob_refcnt` | 引用计数，用于垃圾回收 | 8字节（64位） |
| `ob_type` | 指向类型对象的指针 | 8字节（64位） |

#### 2. 引用计数机制

```python
import sys

# 查看对象的引用计数
a = []
print(sys.getrefcount(a))  # 2（变量a + getrefcount参数）

b = a
print(sys.getrefcount(a))  # 3（变量a + 变量b + getrefcount参数）

del b
print(sys.getrefcount(a))  # 2

# 引用计数的优缺点对比
```

| 引用计数优点 | 引用计数缺点 |
|------------|------------|
| 实时回收，无需等待GC | 无法处理循环引用 |
| 实现简单直观 | 每次赋值都要更新计数（性能开销） |
| 内存占用可预测 | 多线程需要加锁（GIL的原因之一） |

#### 3. 循环引用与垃圾回收

```python
# 循环引用示例
class Node:
    def __init__(self):
        self.ref = None

a = Node()
b = Node()
a.ref = b
b.ref = a  # 循环引用

# 即使删除a和b，它们互相引用，引用计数不为0
del a
del b  # 需要GC来回收

# Python使用分代垃圾回收来处理循环引用
import gc
print(gc.get_count())  # 查看各代对象数量
```

| GC代数 | 触发阈值 | 包含对象 |
|--------|---------|---------|
| 第0代 | 700个对象 | 新创建的对象 |
| 第1代 | 10次0代GC | 0代中存活的对象 |
| 第2代 | 10次1代GC | 1代中存活的对象 |

#### 4. 小对象缓存池

Python对常用小对象使用缓存池优化性能：

```python
# 小整数缓存（-5到256）
a = 100
b = 100
print(a is b)  # True（同一个对象）

a = 1000
b = 1000
print(a is b)  # False（不同对象）

# 字符串驻留（intern）
s1 = 'hello'
s2 = 'hello'
print(s1 is s2)  # True（字符串驻留）

# 短字符串和标识符会自动驻留
s1 = 'hello world'
s2 = 'hello world'
print(s1 is s2)  # False（包含空格，不自动驻留）
```

| 对象类型 | 缓存策略 | 目的 |
|---------|---------|------|
| 小整数 | -5到256预先创建 | 减少频繁创建销毁 |
| 空元组 | 单例模式 | 不可变，共享安全 |
| 小元组 | 缓存长度≤20的空元组 | 快速创建临时元组 |
| 短字符串 | 字符串驻留（intern） | 节省内存，加速比较 |
| None/True/False | 单例模式 | 全局唯一 |

#### 5. 内存布局示例

```python
import sys

# 查看不同对象的内存占用
print(f"int:     {sys.getsizeof(42)} bytes")
print(f"float:   {sys.getsizeof(3.14)} bytes")
print(f"str:     {sys.getsizeof('hello')} bytes")
print(f"list:    {sys.getsizeof([])} bytes")
print(f"dict:    {sys.getsizeof({})} bytes")
print(f"set:     {sys.getsizeof(set())} bytes")
print(f"tuple:   {sys.getsizeof(())} bytes")

# 容器大小随元素增长
lst = []
for i in range(10):
    print(f"list[{i}]: {sys.getsizeof(lst)} bytes")
    lst.append(i)
```

典型输出（64位Python）：

| 对象类型 | 基础大小 | 额外开销 |
|---------|---------|---------|
| 空列表 | 56字节 | +8字节/元素指针 |
| 空字典 | 232字节 | 哈希表开销大 |
| 空集合 | 216字节 | 哈希表开销 |
| 空元组 | 40字节 | +8字节/元素 |
| 整数 | 28字节 | 固定大小 |
| 字符串 | 49+N字节 | N=字符数 |

---

### 第67题：列表的动态数组实现

**问题**：列表在CPython中是如何实现的？为什么append是O(1)，而insert(0)是O(n)？

**答案**：

#### 1. CPython中的列表结构

列表在CPython中使用动态数组（Dynamic Array）实现：

```python
# CPython源码中的PyListObject结构（简化）
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;      # 指向元素数组的指针
    Py_ssize_t allocated;    # 已分配的槽位数量
} PyListObject;
```

| 字段 | 说明 | 作用 |
|------|------|------|
| `ob_item` | PyObject指针数组 | 存储指向实际对象的指针 |
| `ob_size` | 当前元素数量 | len(list)返回这个值 |
| `allocated` | 已分配容量 | ≥ ob_size，预留空间 |

#### 2. 动态扩容机制

```python
# 列表扩容演示
import sys

lst = []
prev_size = sys.getsizeof(lst)

print(f"{'Length':<10} {'Size(bytes)':<15} {'Allocated':<15}")
print("-" * 40)

for i in range(20):
    lst.append(i)
    curr_size = sys.getsizeof(lst)
    if curr_size != prev_size:
        # 计算allocated容量（近似）
        allocated = (curr_size - 56) // 8  # 56是基础开销
        print(f"{len(lst):<10} {curr_size:<15} {allocated:<15}")
        prev_size = curr_size
```

典型输出：

| 长度 | 内存大小 | 已分配容量 | 扩容策略 |
|------|---------|-----------|---------|
| 0 | 56字节 | 0 | 初始状态 |
| 1 | 88字节 | 4 | newsize + (newsize >> 3) + 6 |
| 5 | 120字节 | 8 | 容量翻倍 |
| 9 | 184字节 | 16 | 容量翻倍 |
| 17 | 328字节 | 34 | 增长变慢 |

**CPython扩容算法**（Python 3.9+）：
```
new_allocated = newsize + (newsize >> 3) + 6
# 即：new_allocated = newsize + newsize/8 + 6
```

#### 3. 为什么append是O(1)摊销？

```python
# 摊销分析示例
n = 10000
operations = 0

# 假设每次扩容需要复制所有元素
capacity = 0
size = 0
total_copies = 0

for i in range(n):
    if size >= capacity:
        # 需要扩容
        capacity = max(1, capacity + capacity // 8 + 6)
        total_copies += size  # 复制现有元素
    size += 1
    operations += 1

print(f"总操作数: {operations}")
print(f"总复制数: {total_copies}")
print(f"平均每次操作: {total_copies / operations:.2f}")
# 虽然单次扩容是O(n)，但平均下来是O(1)
```

| 操作 | 最坏情况 | 摊销复杂度 | 原因 |
|------|---------|-----------|------|
| append() | O(n) | O(1) | 扩容时复制，但不频繁 |
| pop() | O(1) | O(1) | 直接删除末尾 |
| pop(0) | O(n) | O(n) | 需要移动所有元素 |
| insert(0, x) | O(n) | O(n) | 需要移动所有元素 |
| insert(i, x) | O(n) | O(n) | 需要移动部分元素 |
| lst[i] | O(1) | O(1) | 直接索引访问 |
| x in lst | O(n) | O(n) | 线性搜索 |

#### 4. 为什么insert(0)是O(n)？

```python
# 可视化insert(0)的过程
"""
初始: [1, 2, 3, 4, 5]
      ↑  ↑  ↑  ↑  ↑
      0  1  2  3  4 (索引)

insert(0, 0)需要：
1. 将索引4的元素移到索引5
2. 将索引3的元素移到索引4
3. 将索引2的元素移到索引3
4. 将索引1的元素移到索引2
5. 将索引0的元素移到索引1
6. 将新元素放到索引0

结果: [0, 1, 2, 3, 4, 5]
"""

# 性能对比
import timeit

# append - 快
def test_append(n):
    lst = []
    for i in range(n):
        lst.append(i)
    return lst

# insert(0) - 慢
def test_insert_0(n):
    lst = []
    for i in range(n):
        lst.insert(0, i)
    return lst

n = 10000
print(f"append:    {timeit.timeit(lambda: test_append(n), number=10):.4f}s")
print(f"insert(0): {timeit.timeit(lambda: test_insert_0(n), number=10):.4f}s")
# insert(0)慢数百倍！
```

#### 5. 内存布局图示

```
列表对象内存布局：

+-------------------+
| PyObject header   |  16字节（引用计数+类型指针）
+-------------------+
| ob_size: 3        |  8字节（当前元素数）
+-------------------+
| allocated: 4      |  8字节（已分配容量）
+-------------------+
| ob_item ----------|---> +--------+--------+--------+--------+
+-------------------+     | ptr[0] | ptr[1] | ptr[2] | NULL   |
                          +--------+--------+--------+--------+
                             |        |        |
                             v        v        v
                          obj_1    obj_2    obj_3
```

#### 6. 优化建议

| 场景 | 不推荐 | 推荐 | 原因 |
|------|--------|------|------|
| 频繁头部操作 | list.insert(0) | collections.deque | deque两端都是O(1) |
| 已知大小 | 动态append | 预分配：[None]*n | 避免多次扩容 |
| 频繁查找 | x in list | x in set | set查找是O(1) |
| 大量拼接 | + 运算符 | extend() | 减少临时对象 |

```python
# 示例：正确的预分配
# 慢
lst = []
for i in range(10000):
    lst.append(0)

# 快
lst = [0] * 10000
for i in range(10000):
    lst[i] = i
```

---

### 第68题：字典和集合的哈希表实现

**问题**：字典和集合在CPython中是如何用哈希表实现的？为什么查找是O(1)？

**答案**：

#### 1. 哈希表基础原理

```python
# 简化的哈希表概念
"""
哈希表通过哈希函数将键映射到数组索引：

键 'apple' -> hash('apple') = 1234567890
           -> index = hash % table_size = 1234567890 % 8 = 2
           -> table[2] = ('apple', value)

查找时：
1. 计算hash('apple')
2. 计算index = hash % table_size
3. 直接访问table[index]
→ O(1)时间复杂度！
"""

# Python中的哈希值
print(hash('apple'))     # 示例：1234567890
print(hash(42))          # 示例：42
print(hash((1, 2, 3)))   # 元组可哈希
# print(hash([1, 2, 3])) # TypeError：列表不可哈希
```

#### 2. CPython字典的结构（Python 3.6+）

Python 3.6+使用紧凑哈希表（Compact Hash Table）：

```python
# 旧实现（Python 3.5-）：稀疏数组，内存浪费
"""
索引:  0    1    2    3    4    5    6    7
      空   键值  空   键值  空   空   键值  空
"""

# 新实现（Python 3.6+）：indices + entries分离
"""
indices数组（存储索引，小整数）：
[EMPTY, 0, EMPTY, 1, EMPTY, EMPTY, 2, EMPTY]

entries数组（紧凑存储）：
[hash, key, value]
[hash, key, value]
[hash, key, value]

优点：
1. 节省内存（约40%）
2. 保持插入顺序（副作用变特性）
3. 键值对紧凑存储
"""
```

**内存对比**：

| Python版本 | 空字典大小 | 10个元素 | 保持顺序 |
|-----------|-----------|---------|---------|
| 3.5及之前 | 280字节 | ~1000字节 | 否 |
| 3.6+ | 232字节 | ~600字节 | 是 |

#### 3. 哈希冲突处理：开放寻址法

```python
# 当两个键哈希到同一个索引时
"""
键'apple'和'banana'都映射到索引2：

初始状态：
indices: [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY]

插入'apple':
indices: [EMPTY, EMPTY, 0, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY]
entries: [('apple', 1)]

插入'banana'（冲突！）:
1. 尝试索引2 → 已占用
2. 探测序列：perturb算法
   next = (5*current + 1 + perturb) % table_size
3. 找到空位，存储

indices: [EMPTY, EMPTY, 0, EMPTY, EMPTY, 1, EMPTY, EMPTY]
entries: [('apple', 1), ('banana', 2)]
"""

# 哈希冲突示例
d = {}
# CPython会自动处理冲突
d['apple'] = 1
d['banana'] = 2
d['cherry'] = 3
```

**探测方法对比**：

| 方法 | 探测序列 | 优点 | 缺点 |
|------|---------|------|------|
| 线性探测 | i+1, i+2, i+3... | 缓存友好 | 聚集问题严重 |
| 二次探测 | i+1², i+2², i+3²... | 减少聚集 | 可能无法遍历全表 |
| CPython | perturb算法 | 随机性好，避免聚集 | 实现复杂 |

#### 4. 动态调整（Rehashing）

```python
# 字典会在负载因子过高时rehash
import sys

d = {}
prev_size = sys.getsizeof(d)

print(f"{'Keys':<10} {'Size(bytes)':<15} {'Capacity':<15}")
print("-" * 45)

for i in range(30):
    d[i] = i
    curr_size = sys.getsizeof(d)
    if curr_size != prev_size:
        print(f"{len(d):<10} {curr_size:<15} {curr_size // 8:<15}")
        prev_size = curr_size

"""
负载因子 = 元素数量 / 表大小

Python字典的rehash策略：
- 初始大小：8
- 负载因子达到2/3时rehash
- 新大小 = 旧大小 * 2（直到50000，之后*4）
"""
```

| 元素数量 | 表大小 | 负载因子 | 操作 |
|---------|--------|---------|------|
| 0 | 8 | 0% | 初始 |
| 6 | 8 | 75% | 触发rehash |
| 6 | 16 | 37.5% | rehash后 |
| 11 | 16 | 68.75% | 触发rehash |
| 11 | 32 | 34.4% | rehash后 |

#### 5. 集合就是"没有值的字典"

```python
# 集合的实现几乎与字典相同
"""
字典: {key: value, ...}
     存储：(hash, key, value)

集合: {key, ...}
     存储：(hash, key)  # 没有value！

因此：
- 集合也是哈希表
- 查找也是O(1)
- 元素也必须可哈希
- 也保持插入顺序（Python 3.7+）
"""

import sys
d = {i: i for i in range(10)}
s = {i for i in range(10)}

print(f"字典10元素: {sys.getsizeof(d)} bytes")
print(f"集合10元素: {sys.getsizeof(s)} bytes")
# 集合稍小（不需要存储value）
```

**字典vs集合对比**：

| 特性 | 字典 | 集合 |
|------|------|------|
| 底层结构 | 哈希表 | 哈希表 |
| 存储内容 | (hash, key, value) | (hash, key) |
| 查找速度 | O(1) | O(1) |
| 内存占用 | 较大 | 较小 |
| 元素要求 | key可哈希 | 元素可哈希 |
| 用途 | 键值映射 | 成员检查、去重 |

#### 6. 哈希函数质量的影响

```python
# 好的哈希函数：均匀分布
class GoodHash:
    def __init__(self, value):
        self.value = value
    def __hash__(self):
        return hash(self.value)
    def __eq__(self, other):
        return self.value == other.value

# 坏的哈希函数：总是返回相同值
class BadHash:
    def __init__(self, value):
        self.value = value
    def __hash__(self):
        return 1  # 糟糕！所有对象都冲突
    def __eq__(self, other):
        return self.value == other.value

# 性能测试
import timeit

# 好的哈希
good_dict = {GoodHash(i): i for i in range(1000)}
good_time = timeit.timeit(lambda: GoodHash(500) in good_dict, number=10000)

# 坏的哈希
bad_dict = {BadHash(i): i for i in range(1000)}
bad_time = timeit.timeit(lambda: BadHash(500) in bad_dict, number=10000)

print(f"好哈希: {good_time:.4f}s")
print(f"坏哈希: {bad_time:.4f}s")  # 慢得多！
```

**哈希质量对性能的影响**：

| 哈希质量 | 冲突率 | 平均查找 | 最坏查找 |
|---------|-------|---------|---------|
| 完美哈希 | 0% | O(1) | O(1) |
| 良好分布 | <10% | O(1) | O(1) |
| 差的分布 | >50% | O(n) | O(n) |
| 所有相同 | 100% | O(n) | O(n) |

#### 7. 可哈希对象要求

```python
# 可哈希的条件
"""
1. 实现__hash__()方法
2. 实现__eq__()方法
3. 哈希值在对象生命周期内不变
4. 相等的对象必须有相同的哈希值
   (a == b) => (hash(a) == hash(b))
"""

# 内置可哈希类型
hashable = [
    int, float, str, bytes,      # 不可变基本类型
    tuple, frozenset,            # 不可变容器
    None, True, False            # 单例
]

# 内置不可哈希类型
non_hashable = [
    list, dict, set, bytearray   # 可变类型
]

# 自定义可哈希类
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash((self.x, self.y))

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

p1 = Point(1, 2)
p2 = Point(1, 2)
print(hash(p1) == hash(p2))  # True
print(p1 == p2)              # True

# 可以作为字典键
d = {p1: 'point1'}
print(d[p2])  # 'point1'（p1和p2是"相等"的键）
```

---

### 第69题：元组的优化实现与性能优势

**问题**：为什么元组比列表快？元组在CPython中有哪些优化？

**答案**：

#### 1. 元组vs列表的底层差异

```python
# CPython中的结构对比

# 列表（PyListObject）
"""
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;     # 指向元素数组的指针
    Py_ssize_t allocated;   # 已分配容量（可能>实际大小）
} PyListObject;
"""

# 元组（PyTupleObject）
"""
typedef struct {
    PyObject_VAR_HEAD
    PyObject *ob_item[1];   # 元素直接嵌入结构体
} PyTupleObject;
"""
```

**关键差异对比**：

| 特性 | 列表 | 元组 | 影响 |
|------|------|------|------|
| 大小 | 可变 | 固定 | 元组创建时就确定 |
| 内存分配 | 两次（对象+数组） | 一次（整体） | 元组更快 |
| allocated字段 | 有（预留空间） | 无 | 元组更省内存 |
| 元素存储 | 间接（指针指向） | 直接（嵌入结构） | 元组访问更快 |

#### 2. 创建速度对比

```python
import timeit

# 测试创建速度
list_time = timeit.timeit('x = [1, 2, 3, 4, 5]', number=1000000)
tuple_time = timeit.timeit('x = (1, 2, 3, 4, 5)', number=1000000)

print(f"列表创建: {list_time:.4f}s")
print(f"元组创建: {tuple_time:.4f}s")
print(f"元组快了: {list_time / tuple_time:.2f}倍")

# 字面量创建
"""
列表字面量 [1,2,3]:
1. 分配PyListObject
2. 分配元素数组
3. 初始化每个元素
4. 设置allocated（可能>3）

元组字面量 (1,2,3):
1. 分配PyTupleObject（包含元素）
2. 初始化每个元素
→ 步骤更少！
"""
```

典型结果：

| 操作 | 列表 | 元组 | 元组优势 |
|------|------|------|---------|
| 创建空容器 | 0.05s | 0.02s | 2.5倍 |
| 创建5元素 | 0.08s | 0.03s | 2.7倍 |
| 创建100元素 | 0.50s | 0.35s | 1.4倍 |

#### 3. 小元组缓存机制

```python
# CPython对小元组有缓存优化
import sys

# 长度≤20的空元组会被缓存
t1 = ()
t2 = ()
print(t1 is t2)  # True（同一个对象！）
print(id(t1) == id(t2))  # True

# 但非空元组不会缓存
t1 = (1, 2, 3)
t2 = (1, 2, 3)
print(t1 is t2)  # False（不同对象）
print(t1 == t2)  # True（值相等）

# 元组缓存池
"""
CPython维护一个free_list数组：
- free_list[0]到free_list[20]
- 分别缓存长度0-20的元组
- 回收时放入对应链表
- 创建时优先从free_list取

好处：
- 减少malloc/free调用
- 创建空元组几乎零成本
- 适合临时元组（如函数返回多值）
"""
```

**缓存效果**：

| 元组类型 | 无缓存时间 | 有缓存时间 | 提升 |
|---------|-----------|-----------|------|
| 空元组() | 0.05s | 0.001s | 50倍 |
| 单元素(1,) | 0.04s | 0.03s | 1.3倍 |
| 10元素 | 0.30s | 0.28s | 1.1倍 |

#### 4. 内存占用对比

```python
import sys

# 相同元素的内存占用
list_obj = [1, 2, 3, 4, 5]
tuple_obj = (1, 2, 3, 4, 5)

print(f"列表: {sys.getsizeof(list_obj)} bytes")
print(f"元组: {sys.getsizeof(tuple_obj)} bytes")

# 空容器
print(f"空列表: {sys.getsizeof([])} bytes")
print(f"空元组: {sys.getsizeof(())} bytes")

# 100元素
large_list = list(range(100))
large_tuple = tuple(range(100))
print(f"100元素列表: {sys.getsizeof(large_list)} bytes")
print(f"100元素元组: {sys.getsizeof(large_tuple)} bytes")
```

典型内存占用（64位Python）：

| 容器大小 | 列表 | 元组 | 节省 |
|---------|------|------|------|
| 空容器 | 56字节 | 40字节 | 28% |
| 5元素 | 96字节 | 80字节 | 17% |
| 100元素 | 856字节 | 840字节 | 2% |
| 1000元素 | 8056字节 | 8040字节 | 0.2% |

**元组更省内存的原因**：
- 没有`allocated`字段（8字节）
- 没有预留空间
- 结构更紧凑

#### 5. 访问速度对比

```python
import timeit

# 元素访问速度
lst = [1, 2, 3, 4, 5]
tpl = (1, 2, 3, 4, 5)

list_access = timeit.timeit('x = lst[2]', globals=globals(), number=10000000)
tuple_access = timeit.timeit('x = tpl[2]', globals=globals(), number=10000000)

print(f"列表访问: {list_access:.4f}s")
print(f"元组访问: {tuple_access:.4f}s")
# 差异很小，但元组略快
```

| 操作 | 列表 | 元组 | 差异 |
|------|------|------|------|
| 索引访问 | O(1) | O(1) | 元组快~5% |
| 切片 | O(k) | O(k) | 元组快~10% |
| 迭代 | O(n) | O(n) | 元组快~5-10% |
| len() | O(1) | O(1) | 几乎相同 |

#### 6. 不可变性带来的优化

```python
# 常量折叠优化
import dis

# 元组可以在编译时优化
def with_tuple():
    return (1, 2, 3)

# 列表不能优化（可变）
def with_list():
    return [1, 2, 3]

print("元组版本字节码：")
dis.dis(with_tuple)
# LOAD_CONST (1, 2, 3)  # 元组作为常量！

print("\n列表版本字节码：")
dis.dis(with_list)
# BUILD_LIST  # 每次都构建新列表

"""
元组的常量折叠：
- 字面量元组在编译时创建
- 函数调用时直接返回常量
- 不需要每次构建

列表不能折叠：
- 可变对象不能作为常量
- 每次调用都要重新构建
→ 元组更快！
"""
```

**编译时优化对比**：

| 代码 | 优化 | 执行次数 | 原因 |
|------|------|---------|------|
| return (1,2,3) | 可折叠 | 创建1次 | 不可变 |
| return [1,2,3] | 不可折叠 | 创建N次 | 可变 |
| x=(1,)+y | 部分 | 优化(1,) | 部分不可变 |

#### 7. 哈希计算

```python
# 元组可哈希，列表不可哈希
t = (1, 2, 3)
print(hash(t))  # 成功

# lst = [1, 2, 3]
# print(hash(lst))  # TypeError

# 哈希缓存
"""
元组的哈希值会被缓存：

typedef struct {
    PyObject_VAR_HEAD
    Py_hash_t ob_hash;      # 缓存的哈希值（-1表示未计算）
    PyObject *ob_item[1];
} PyTupleObject;

第一次计算后：
t = (1, 2, 3)
hash(t)  # 计算并缓存
hash(t)  # 直接返回缓存值（更快！）
"""

import timeit

# 大元组哈希性能
big_tuple = tuple(range(1000))

# 第一次计算
first = timeit.timeit(lambda: hash(big_tuple), number=1)
# 后续访问
cached = timeit.timeit(lambda: hash(big_tuple), number=100000)

print(f"首次哈希: {first:.6f}s")
print(f"缓存哈希: {cached:.6f}s")
print(f"缓存快了: {first / (cached/100000):.0f}倍")
```

**哈希缓存优势**：

| 场景 | 无缓存 | 有缓存 | 应用 |
|------|-------|--------|------|
| 字典键查找 | 每次计算 | 首次计算 | 元组作为键更快 |
| 集合成员检查 | 每次计算 | 首次计算 | frozenset高效 |
| 重复哈希 | O(n) | O(1) | 大元组优势明显 |

#### 8. 何时使用元组vs列表

| 场景 | 推荐 | 原因 |
|------|------|------|
| 函数返回多值 | 元组 | 更快，表达不可变 |
| 字典键 | 元组 | 可哈希 |
| 配置/常量 | 元组 | 防止意外修改 |
| 需要修改 | 列表 | 可变 |
| 需要方法(append等) | 列表 | 功能丰富 |
| 临时存储 | 元组 | 缓存优化 |
| 大量数据 | 取决 | 小数据用元组，大数据差异小 |

```python
# 最佳实践示例

# 好：函数返回多值用元组
def get_user():
    return ('Alice', 25, 'NYC')  # 元组

# 好：固定配置用元组
DIRECTIONS = ('north', 'south', 'east', 'west')

# 好：字典键用元组
positions = {
    (0, 0): 'origin',
    (1, 0): 'right',
    (0, 1): 'up'
}

# 好：需要修改用列表
numbers = [1, 2, 3]
numbers.append(4)
numbers.remove(1)

# 性能对比总结
"""
元组比列表快的情况：
1. 创建：快20-150%
2. 常量折叠：快100%+
3. 哈希缓存：快N倍（N=元组大小）
4. 小元组缓存：快50倍（空元组）

列表比元组快的情况：
（无）列表功能更多但不更快
"""
```

---

## 列表部分

### 第31题：列表创建与访问

**问题**：列表的创建和访问方式

**答案**：
```python
# 创建列表
empty_list = []
nums = [1, 2, 3, 4, 5]
mixed = [1, 'hello', 3.14, True]
nested = [[1, 2], [3, 4], [5, 6]]

# 使用list()
lst = list(range(5))  # [0, 1, 2, 3, 4]
chars = list('hello')  # ['h', 'e', 'l', 'l', 'o']

# 访问元素
print(nums[0])    # 1 (第一个)
print(nums[-1])   # 5 (最后一个)
print(nums[-2])   # 4 (倒数第二个)

# 切片
print(nums[1:4])  # [2, 3, 4]
print(nums[:3])   # [1, 2, 3]
print(nums[2:])   # [3, 4, 5]
print(nums[::2])  # [1, 3, 5] (步长为2)
print(nums[::-1]) # [5, 4, 3, 2, 1] (反转)
```

---

### 第32题：列表修改操作

**问题**：列表的增删改操作

**答案**：
```python
nums = [1, 2, 3, 4, 5]

# 添加元素
nums.append(6)           # 末尾添加: [1, 2, 3, 4, 5, 6]
nums.insert(0, 0)        # 指定位置插入: [0, 1, 2, 3, 4, 5, 6]
nums.extend([7, 8])      # 扩展列表: [0, 1, 2, 3, 4, 5, 6, 7, 8]

# 删除元素
nums.remove(0)           # 删除第一个匹配的值
del nums[0]              # 删除指定索引
popped = nums.pop()      # 删除并返回最后一个元素
popped = nums.pop(0)     # 删除并返回指定索引元素
nums.clear()             # 清空列表

# 修改元素
nums = [1, 2, 3, 4, 5]
nums[0] = 10             # 修改单个: [10, 2, 3, 4, 5]
nums[1:3] = [20, 30]     # 修改切片: [10, 20, 30, 4, 5]
```

---

### 第33题：列表常用方法

**问题**：列表的其他常用方法

**答案**：
```python
nums = [3, 1, 4, 1, 5, 9, 2, 6]

# 排序
nums.sort()              # 原地排序: [1, 1, 2, 3, 4, 5, 6, 9]
nums.sort(reverse=True)  # 降序: [9, 6, 5, 4, 3, 2, 1, 1]
sorted_nums = sorted(nums)  # 返回新列表，原列表不变

# 反转
nums.reverse()           # 原地反转
reversed_nums = nums[::-1]  # 返回新列表

# 统计
print(nums.count(1))     # 统计元素出现次数
print(nums.index(5))     # 查找元素索引（第一次出现）
print(len(nums))         # 列表长度

# 复制
nums_copy = nums.copy()  # 浅拷贝
nums_copy = nums[:]      # 切片复制
import copy
deep_copy = copy.deepcopy(nums)  # 深拷贝

# 最大最小和
print(max(nums))
print(min(nums))
print(sum(nums))
```

---

### 第34题：列表推导式

**问题**：列表推导式的高级用法

**答案**：
```python
# 基本形式
squares = [x**2 for x in range(10)]

# 带条件
evens = [x for x in range(10) if x % 2 == 0]

# 多个条件
nums = [x for x in range(20) if x % 2 == 0 if x % 3 == 0]
# [0, 6, 12, 18]

# if-else表达式
labels = ['even' if x % 2 == 0 else 'odd' for x in range(5)]

# 嵌套循环
pairs = [(x, y) for x in range(3) for y in range(3)]
# [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]

# 带条件的嵌套
pairs = [(x, y) for x in range(5) for y in range(5) if x != y]

# 展平嵌套列表
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 字符串处理
words = ['hello', 'world']
chars = [c for word in words for c in word]
# ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
```

---

### 第35题：列表解包

**问题**：列表的解包操作

**答案**：
```python
# 基本解包
a, b, c = [1, 2, 3]
print(a, b, c)  # 1 2 3

# 使用*收集剩余元素
a, *b, c = [1, 2, 3, 4, 5]
print(a)  # 1
print(b)  # [2, 3, 4]
print(c)  # 5

# 忽略某些值
a, _, c = [1, 2, 3]
print(a, c)  # 1 3

# 嵌套解包
(a, b), (c, d) = [[1, 2], [3, 4]]
print(a, b, c, d)  # 1 2 3 4

# 交换变量
a, b = 1, 2
a, b = b, a
print(a, b)  # 2 1

# 函数参数解包
def add(a, b, c):
    return a + b + c

nums = [1, 2, 3]
print(add(*nums))  # 6
```

---

### 第36题：列表的浅拷贝vs深拷贝

**问题**：说明浅拷贝和深拷贝的区别

**答案**：
```python
import copy

# 赋值（不是拷贝）
a = [1, 2, 3]
b = a
b[0] = 999
print(a)  # [999, 2, 3] - a也改变了

# 浅拷贝
a = [[1, 2], [3, 4]]
b = a.copy()  # 或 a[:] 或 list(a)
b[0][0] = 999
print(a)  # [[999, 2], [3, 4]] - 嵌套对象受影响

# 深拷贝
a = [[1, 2], [3, 4]]
b = copy.deepcopy(a)
b[0][0] = 999
print(a)  # [[1, 2], [3, 4]] - a不受影响

# 实际例子
original = [1, [2, 3], 4]

# 浅拷贝
shallow = original[:]
shallow[1][0] = 999
print(original)  # [1, [999, 3], 4]

# 深拷贝
original = [1, [2, 3], 4]
deep = copy.deepcopy(original)
deep[1][0] = 999
print(original)  # [1, [2, 3], 4]
```

---

### 第37题：列表排序技巧

**问题**：列表排序的高级用法

**答案**：
```python
# 基本排序
nums = [3, 1, 4, 1, 5, 9]
nums.sort()
print(nums)  # [1, 1, 3, 4, 5, 9]

# 自定义排序
# 按绝对值排序
nums = [-5, -2, 3, 1, -4]
nums.sort(key=abs)
print(nums)  # [1, -2, 3, -4, -5]

# 按字符串长度排序
words = ['apple', 'pie', 'a', 'cherry']
words.sort(key=len)
print(words)  # ['a', 'pie', 'apple', 'cherry']

# 复杂对象排序
students = [
    {'name': 'Alice', 'grade': 85},
    {'name': 'Bob', 'grade': 92},
    {'name': 'Charlie', 'grade': 78}
]
students.sort(key=lambda x: x['grade'], reverse=True)
print(students)

# 多级排序
data = [(1, 3), (1, 2), (2, 1)]
data.sort(key=lambda x: (x[0], x[1]))
print(data)  # [(1, 2), (1, 3), (2, 1)]

# 使用operator模块
from operator import itemgetter
students.sort(key=itemgetter('grade'), reverse=True)
print(students)
```

---

### 第38题：列表去重

**问题**：去除列表中的重复元素

**答案**：
```python
# 方法1: 转换为集合（不保持顺序）
nums = [1, 2, 2, 3, 3, 3, 4]
unique = list(set(nums))
print(unique)  # [1, 2, 3, 4] (顺序可能变化)

# 方法2: 保持顺序（推荐）
def remove_duplicates(lst):
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result

nums = [1, 2, 2, 3, 3, 3, 4]
print(remove_duplicates(nums))  # [1, 2, 3, 4]

# 方法3: 使用dict（Python 3.7+字典有序）
nums = [1, 2, 2, 3, 3, 3, 4]
unique = list(dict.fromkeys(nums))
print(unique)  # [1, 2, 3, 4]

# 方法4: 列表推导式
def remove_duplicates_v2(lst):
    seen = []
    return [x for x in lst if x not in seen and not seen.append(x)]

print(remove_duplicates_v2(nums))  # [1, 2, 3, 4]
```

---

### 第39题：列表切片赋值

**问题**：切片赋值的特殊用法

**答案**：
```python
nums = [1, 2, 3, 4, 5]

# 替换切片
nums[1:3] = [20, 30]
print(nums)  # [1, 20, 30, 4, 5]

# 插入元素
nums[2:2] = [100, 200]
print(nums)  # [1, 20, 100, 200, 30, 4, 5]

# 删除切片
nums[1:4] = []
print(nums)  # [1, 30, 4, 5]

# 替换为不同长度
nums = [1, 2, 3, 4, 5]
nums[1:4] = [10]
print(nums)  # [1, 10, 5]

# 反转列表
nums = [1, 2, 3, 4, 5]
nums[:] = nums[::-1]
print(nums)  # [5, 4, 3, 2, 1]

# 清空列表
nums[:] = []
print(nums)  # []
```

---

### 第40题：列表常见操作复杂度

**问题**：列表各种操作的时间复杂度

**答案**：
```python
"""
列表操作的时间复杂度：

O(1) - 常数时间：
- 访问元素: lst[i]
- 修改元素: lst[i] = x
- 末尾添加: lst.append(x)
- 末尾删除: lst.pop()
- 获取长度: len(lst)

O(n) - 线性时间：
- 查找元素: x in lst
- 删除元素: lst.remove(x)
- 头部插入: lst.insert(0, x)
- 头部删除: lst.pop(0)
- 复制: lst.copy()
- 反转: lst.reverse()
- 统计: lst.count(x)

O(n log n) - 对数线性时间：
- 排序: lst.sort()

O(k) - k为切片长度：
- 切片操作: lst[i:j]
"""

# 性能对比示例
import time

# append vs insert(0)
def test_append(n):
    lst = []
    for i in range(n):
        lst.append(i)

def test_insert(n):
    lst = []
    for i in range(n):
        lst.insert(0, i)

# append更快，insert(0)需要移动所有元素
```

---

### 第41题：列表实现栈和队列

**问题**：使用列表实现栈和队列

**答案**：
```python
# 栈（Stack）- LIFO（后进先出）
stack = []

# 入栈
stack.append(1)
stack.append(2)
stack.append(3)

# 出栈
print(stack.pop())  # 3
print(stack.pop())  # 2

# 查看栈顶
if stack:
    print(stack[-1])  # 1

# 队列（Queue）- FIFO（先进先出）
# 不推荐使用列表，应该使用collections.deque
from collections import deque

queue = deque()

# 入队
queue.append(1)
queue.append(2)
queue.append(3)

# 出队
print(queue.popleft())  # 1
print(queue.popleft())  # 2

# 查看队首
if queue:
    print(queue[0])  # 3
```

---

### 第42题：列表合并与连接

**问题**：合并多个列表的不同方式

**答案**：
```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list3 = [7, 8, 9]

# 方法1: + 运算符
result = list1 + list2 + list3
print(result)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 方法2: extend
result = list1.copy()
result.extend(list2)
result.extend(list3)

# 方法3: 列表推导式
result = [item for lst in [list1, list2, list3] for item in lst]

# 方法4: itertools.chain
from itertools import chain
result = list(chain(list1, list2, list3))

# 方法5: sum（不推荐，性能差）
result = sum([list1, list2, list3], [])

# 方法6: *解包（Python 3.5+）
result = [*list1, *list2, *list3]

# 性能对比
import timeit
# extend最快，sum最慢
```

---

## 元组部分

### 第43题：元组基础

**问题**：元组的特点和基本操作

**答案**：
```python
# 创建元组
empty = ()
single = (1,)  # 注意逗号
nums = (1, 2, 3, 4, 5)
mixed = (1, 'hello', 3.14, True)

# 不需要括号
coords = 1, 2, 3
print(type(coords))  # <class 'tuple'>

# 访问元素（同列表）
print(nums[0])    # 1
print(nums[-1])   # 5
print(nums[1:3])  # (2, 3)

# 元组是不可变的
#nums[0] = 10  # TypeError

# 但可以包含可变对象
t = ([1, 2], [3, 4])
t[0].append(3)
print(t)  # ([1, 2, 3], [3, 4])

# 元组方法（只有两个）
print(nums.count(2))  # 1
print(nums.index(3))  # 2
```

---

### 第44题：元组解包

**问题**：元组解包的各种用法

**答案**：
```python
# 基本解包
point = (3, 4)
x, y = point
print(x, y)  # 3 4

# 函数返回多个值（实际返回元组）
def get_user():
    return 'Alice', 25, 'NYC'

name, age, city = get_user()

# *收集剩余元素
a, *b, c = (1, 2, 3, 4, 5)
print(b)  # [2, 3, 4]

# 交换变量
x, y = 1, 2
x, y = y, x

# 遍历键值对
d = {'a': 1, 'b': 2, 'c': 3}
for key, value in d.items():
    print(f"{key}: {value}")

# 同时遍历多个列表
names = ['Alice', 'Bob']
ages = [25, 30]
for name, age in zip(names, ages):
    print(f"{name} is {age}")

# 嵌套解包
data = [('Alice', (25, 'NYC')), ('Bob', (30, 'LA'))]
for name, (age, city) in data:
    print(f"{name}, {age}, {city}")
```

---

### 第45题：命名元组

**问题**：使用namedtuple创建有名字的元组

**答案**：
```python
from collections import namedtuple

# 创建命名元组类
Point = namedtuple('Point', ['x', 'y'])
# 或者使用字符串
Point = namedtuple('Point', 'x y')

# 创建实例
p = Point(3, 4)

# 访问
print(p.x, p.y)  # 3 4
print(p[0], p[1])  # 3 4

# 不可变
# p.x = 5  # AttributeError

# 转换为字典
print(p._asdict())  # {'x': 3, 'y': 4}

# 替换值（返回新元组）
p2 = p._replace(x=10)
print(p2)  # Point(x=10, y=4)

# 实际应用
Person = namedtuple('Person', ['name', 'age', 'city'])
alice = Person('Alice', 25, 'NYC')
print(alice.name)  # Alice

# 带默认值（Python 3.7+）
Person = namedtuple('Person', ['name', 'age', 'city'],
                    defaults=['Unknown', 0, 'Unknown'])
bob = Person('Bob')
print(bob)  # Person(name='Bob', age=0, city='Unknown')
```

---

### 第46题：元组作为字典键

**问题**：为什么元组可以作为字典键？

**答案**：
```python
# 元组是不可变的，可以作为字典键
locations = {
    (40.7128, -74.0060): 'New York',
    (34.0522, -118.2437): 'Los Angeles',
    (41.8781, -87.6298): 'Chicago'
}

print(locations[(40.7128, -74.0060)])  # New York

# 列表不可哈希，不能作为键
# locations[[1, 2]] = 'test'  # TypeError

# 应用：缓存函数结果
cache = {}

def fibonacci(n):
    if n in cache:
        return cache[n]
    if n <= 1:
        return n
    result = fibonacci(n-1) + fibonacci(n-2)
    cache[n] = result
    return result

# 多参数缓存
def add(a, b):
    key = (a, b)
    if key not in cache:
        cache[key] = a + b
    return cache[key]
```

---

### 第47题：元组的不可变性

**问题**：深入理解元组的不可变性

**答案**：
```python
# 元组本身不可变
t = (1, 2, 3)
# t[0] = 10  # TypeError

# 但元组中的可变对象可以修改
t = ([1, 2], [3, 4])
t[0].append(3)
print(t)  # ([1, 2, 3], [3, 4])

# 元组的"修改"实际是创建新元组
t = (1, 2, 3)
t = t + (4, 5)
print(t)  # (1, 2, 3, 4, 5)

# id会改变，说明是新对象
t1 = (1, 2, 3)
print(id(t1))
t1 = t1 + (4,)
print(id(t1))  # 不同的id

# 对比列表
lst = [1, 2, 3]
print(id(lst))
lst.append(4)
print(id(lst))  # 相同的id

# 元组的优势
# 1. 更快（创建和访问）
# 2. 可以作为字典键
# 3. 保护数据不被修改
```

---

### 第48题：元组vs列表性能

**问题**：元组和列表的性能对比

**答案**：
```python
import sys
import timeit

# 内存占用
list_obj = [1, 2, 3, 4, 5]
tuple_obj = (1, 2, 3, 4, 5)

print(sys.getsizeof(list_obj))   # 更大
print(sys.getsizeof(tuple_obj))  # 更小

# 创建速度
def create_list():
    return [1, 2, 3, 4, 5]

def create_tuple():
    return (1, 2, 3, 4, 5)

print(timeit.timeit(create_list, number=1000000))
print(timeit.timeit(create_tuple, number=1000000))  # 更快

# 访问速度（差不多）
list_obj = [1, 2, 3, 4, 5]
tuple_obj = (1, 2, 3, 4, 5)

print(timeit.timeit('list_obj[2]', globals=globals(), number=1000000))
print(timeit.timeit('tuple_obj[2]', globals=globals(), number=1000000))

# 总结：元组更适合不需要修改的数据
```

---

## 字典部分

### 第49题：字典创建与访问

**问题**：字典的各种创建方式

**答案**：
```python
# 方式1: 字面量
d = {'name': 'Alice', 'age': 25}

# 方式2: dict()
d = dict(name='Alice', age=25)

# 方式3: 键值对列表
pairs = [('name', 'Alice'), ('age', 25)]
d = dict(pairs)

# 方式4: fromkeys
keys = ['a', 'b', 'c']
d = dict.fromkeys(keys, 0)  # {'a': 0, 'b': 0, 'c': 0}

# 方式5: 字典推导式
d = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 访问
print(d['name'])  # Alice
# print(d['city'])  # KeyError

# 安全访问
print(d.get('city'))  # None
print(d.get('city', 'NYC'))  # NYC (默认值)

# setdefault
age = d.setdefault('age', 0)  # 如果不存在则设置
```

---

### 第50题：字典操作方法

**问题**：字典的常用方法

**答案**：
```python
d = {'name': 'Alice', 'age': 25, 'city': 'NYC'}

# 获取所有键
print(d.keys())    # dict_keys(['name', 'age', 'city'])
print(list(d.keys()))  # ['name', 'age', 'city']

# 获取所有值
print(d.values())  # dict_values(['Alice', 25, 'NYC'])

# 获取所有键值对
print(d.items())   # dict_items([('name', 'Alice'), ...])

# 遍历
for key in d:
    print(key, d[key])

for key, value in d.items():
    print(key, value)

# 更新
d.update({'age': 26, 'job': 'Engineer'})
print(d)

# 删除
del d['city']
age = d.pop('age')  # 删除并返回值
city = d.pop('city', 'Unknown')  # 带默认值

# 清空
d.clear()

# 检查键是否存在
if 'name' in d:
    print(d['name'])
```

---

### 第51题：字典推导式

**问题**：字典推导式的用法

**答案**：
```python
# 基本形式
squares = {x: x**2 for x in range(6)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 带条件
even_squares = {x: x**2 for x in range(10) if x % 2 == 0}

# 交换键值
d = {'a': 1, 'b': 2, 'c': 3}
reversed_d = {v: k for k, v in d.items()}
# {1: 'a', 2: 'b', 3: 'c'}

# 过滤字典
scores = {'Alice': 85, 'Bob': 92, 'Charlie': 78, 'David': 95}
high_scores = {k: v for k, v in scores.items() if v >= 90}
print(high_scores)
# {'Bob': 92, 'David': 95}

# 字符串处理
text = "hello world"
char_count = {char: text.count(char) for char in set(text)}

# 合并两个列表
keys = ['a', 'b', 'c']
values = [1, 2, 3]
d = {k: v for k, v in zip(keys, values)}

# 嵌套推导式
matrix = {
    i: {j: i*j for j in range(1, 4)}
    for i in range(1, 4)
}
# {1: {1: 1, 2: 2, 3: 3}, 2: {1: 2, 2: 4, 3: 6}, ...}
```

---

### 第52题：defaultdict

**问题**：使用defaultdict简化字典操作

**答案**：
```python
from collections import defaultdict

# 普通字典需要检查键是否存在
d = {}
for word in ['apple', 'banana', 'apple']:
    if word not in d:
        d[word] = 0
    d[word] += 1
print(d)

# defaultdict自动创建默认值
d = defaultdict(int)
for word in ['apple', 'banana', 'apple']:
    d[word] += 1
print(dict(d))  # {'apple': 2, 'banana': 1}

# 不同的默认工厂函数
d = defaultdict(list)
d['fruits'].append('apple')
d['fruits'].append('banana')
print(dict(d))  # {'fruits': ['apple', 'banana']}

d = defaultdict(set)
d['tags'].add('python')
d['tags'].add('coding')
print(dict(d))

# 自定义默认值
d = defaultdict(lambda: 'Unknown')
print(d['name'])  # 'Unknown'

# 实际应用：分组
students = [
    {'name': 'Alice', 'grade': 'A'},
    {'name': 'Bob', 'grade': 'B'},
    {'name': 'Charlie', 'grade': 'A'}
]

groups = defaultdict(list)
for student in students:
    groups[student['grade']].append(student['name'])

print(dict(groups))
# {'A': ['Alice', 'Charlie'], 'B': ['Bob']}
```

---

### 第53题：Counter

**问题**：使用Counter统计元素出现次数

**答案**：
```python
from collections import Counter

# 基本用法
words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
counter = Counter(words)
print(counter)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})

# 字符串统计
text = "hello world"
char_count = Counter(text)
print(char_count)  # Counter({'l': 3, 'o': 2, ...})

# 最常见的元素
print(counter.most_common(2))  # [('apple', 3), ('banana', 2)]

# 算术运算
c1 = Counter(['a', 'b', 'c', 'a'])
c2 = Counter(['a', 'b', 'd'])

print(c1 + c2)  # Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})
print(c1 - c2)  # Counter({'a': 1, 'c': 1})
print(c1 & c2)  # Counter({'a': 1, 'b': 1})  # 取最小
print(c1 | c2)  # Counter({'a': 2, 'b': 1, 'c': 1, 'd': 1})  # 取最大

# 更新
counter.update(['apple', 'date'])
print(counter)

# 删除计数为0或负数的元素
counter['banana'] = 0
+counter  # 移除非正数计数

# 实际应用：找出现最多的单词
text = "this is a test this is only a test"
words = text.split()
counter = Counter(words)
print(counter.most_common(1))  # [('this', 2)]
```

---

### 第54题：OrderedDict

**问题**：有序字典的使用（Python 3.7+普通字典已有序）

**答案**：
```python
from collections import OrderedDict

# Python 3.7+之前，普通dict无序
# OrderedDict记住插入顺序
d = OrderedDict()
d['a'] = 1
d['b'] = 2
d['c'] = 3

print(list(d.keys()))  # ['a', 'b', 'c']

# 移动到末尾
d.move_to_end('a')
print(list(d.keys()))  # ['b', 'c', 'a']

# 移动到开头
d.move_to_end('c', last=False)
print(list(d.keys()))  # ['c', 'b', 'a']

# popitem
d.popitem()  # 删除最后一个
d.popitem(last=False)  # 删除第一个

# Python 3.7+普通dict也保持插入顺序
d = {}
d['a'] = 1
d['b'] = 2
d['c'] = 3
print(list(d.keys()))  # ['a', 'b', 'c']

# 但OrderedDict在相等性检查时考虑顺序
d1 = OrderedDict([('a', 1), ('b', 2)])
d2 = OrderedDict([('b', 2), ('a', 1)])
print(d1 == d2)  # False

d1 = {'a': 1, 'b': 2}
d2 = {'b': 2, 'a': 1}
print(d1 == d2)  # True
```

---

### 第55题：字典合并

**问题**：合并多个字典的方法

**答案**：
```python
d1 = {'a': 1, 'b': 2}
d2 = {'b': 3, 'c': 4}

# 方法1: update（修改原字典）
d = d1.copy()
d.update(d2)
print(d)  # {'a': 1, 'b': 3, 'c': 4}

# 方法2: ** 解包（Python 3.5+）
d = {**d1, **d2}
print(d)  # {'a': 1, 'b': 3, 'c': 4}

# 方法3: | 运算符（Python 3.9+）
d = d1 | d2
print(d)  # {'a': 1, 'b': 3, 'c': 4}

# 方法4: |= 运算符（Python 3.9+）
d = d1.copy()
d |= d2
print(d)

# 合并多个字典
d1 = {'a': 1}
d2 = {'b': 2}
d3 = {'c': 3}

# 使用解包
d = {**d1, **d2, **d3}

# 使用reduce
from functools import reduce
d = reduce(lambda x, y: {**x, **y}, [d1, d2, d3])

# ChainMap（不复制，创建视图）
from collections import ChainMap
d = ChainMap(d1, d2, d3)
print(d['a'])  # 1
```

---

### 第56题：字典嵌套操作

**问题**：处理嵌套字典

**答案**：
```python
# 创建嵌套字典
data = {
    'users': {
        'alice': {'age': 25, 'city': 'NYC'},
        'bob': {'age': 30, 'city': 'LA'}
    }
}

# 访问嵌套值
print(data['users']['alice']['age'])  # 25

# 安全访问
age = data.get('users', {}).get('alice', {}).get('age')

# 修改嵌套值
data['users']['alice']['age'] = 26

# 添加嵌套值
data['users']['charlie'] = {'age': 35, 'city': 'Chicago'}

# 遍历嵌套字典
for user, info in data['users'].items():
    print(f"{user}: {info['age']}, {info['city']}")

# 展平嵌套字典
def flatten_dict(d, parent_key='', sep='_'):
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

data = {'a': 1, 'b': {'c': 2, 'd': {'e': 3}}}
print(flatten_dict(data))
# {'a': 1, 'b_c': 2, 'b_d_e': 3}
```

---

### 第57题：字典视图对象

**问题**：理解字典的视图对象

**答案**：
```python
d = {'a': 1, 'b': 2, 'c': 3}

# keys(), values(), items()返回视图对象
keys = d.keys()
values = d.values()
items = d.items()

print(type(keys))  # <class 'dict_keys'>

# 视图是动态的
d['d'] = 4
print(list(keys))  # ['a', 'b', 'c', 'd']

# 视图支持集合操作（keys和items）
d1 = {'a': 1, 'b': 2}
d2 = {'b': 2, 'c': 3}

# 交集
print(d1.keys() & d2.keys())  # {'b'}

# 并集
print(d1.keys() | d2.keys())  # {'a', 'b', 'c'}

# 差集
print(d1.keys() - d2.keys())  # {'a'}

# 对称差集
print(d1.keys() ^ d2.keys())  # {'a', 'c'}

# items视图也支持集合操作
print(d1.items() & d2.items())  # {('b', 2)}
```

---

### 第58题：字典性能技巧

**问题**：字典的性能优化技巧

**答案**：
```python
# 1. 使用in检查键（O(1)）
d = {'a': 1, 'b': 2}
if 'a' in d:  # 快
    print(d['a'])

# 2. 避免重复查询
# 慢
if 'key' in d:
    value = d['key']

# 快
value = d.get('key')
if value is not None:
    pass

# 3. setdefault减少查询
# 慢
if 'count' not in d:
    d['count'] = 0
d['count'] += 1

# 快
d.setdefault('count', 0)
d['count'] += 1

# 或使用defaultdict
from collections import defaultdict
d = defaultdict(int)
d['count'] += 1

# 4. 批量更新使用update
# 慢
for k, v in pairs:
    d[k] = v

# 快
d.update(pairs)

# 5. 字典推导式通常比循环快
# 慢
d = {}
for i in range(100):
    d[i] = i**2

# 快
d = {i: i**2 for i in range(100)}
```

---

## 集合部分

### 第59题：集合基础

**问题**：集合的创建和特点

**答案**：
```python
# 创建集合
s = {1, 2, 3, 4, 5}
s = set([1, 2, 3, 4, 5])
s = set('hello')  # {'h', 'e', 'l', 'o'}

# 空集合
s = set()  # 注意：{}是空字典

# 集合特点
# 1. 无序
# 2. 元素唯一（自动去重）
# 3. 元素必须可哈希

s = {1, 2, 2, 3, 3, 3}
print(s)  # {1, 2, 3}

# 不可变元素
s = {1, 'hello', (1, 2)}  # OK
# s = {[1, 2]}  # TypeError: 列表不可哈希

# 基本操作
s.add(6)       # 添加元素
s.remove(1)    # 删除元素（不存在会报错）
s.discard(1)   # 删除元素（不存在不报错）
s.pop()        # 随机删除并返回
s.clear()      # 清空

# 检查元素
print(2 in s)
print(len(s))
```

---

### 第60题：集合运算

**问题**：集合的数学运算

**答案**：
```python
a = {1, 2, 3, 4, 5}
b = {4, 5, 6, 7, 8}

# 并集
print(a | b)  # {1, 2, 3, 4, 5, 6, 7, 8}
print(a.union(b))

# 交集
print(a & b)  # {4, 5}
print(a.intersection(b))

# 差集
print(a - b)  # {1, 2, 3}
print(a.difference(b))

# 对称差集
print(a ^ b)  # {1, 2, 3, 6, 7, 8}
print(a.symmetric_difference(b))

# 更新操作（修改原集合）
a |= b  # a = a | b
a &= b  # a = a & b
a -= b  # a = a - b
a ^= b  # a = a ^ b

# 对应的方法
a.update(b)
a.intersection_update(b)
a.difference_update(b)
a.symmetric_difference_update(b)
```

---

### 第61题：集合关系判断

**问题**：判断集合之间的关系

**答案**：
```python
a = {1, 2, 3}
b = {1, 2, 3, 4, 5}

# 子集
print(a <= b)  # True
print(a.issubset(b))  # True

# 真子集
print(a < b)  # True

# 超集
print(b >= a)  # True
print(b.issuperset(a))  # True

# 真超集
print(b > a)  # True

# 不相交
c = {4, 5, 6}
print(a.isdisjoint(c))  # True（没有公共元素）

# 相等
d = {3, 2, 1}
print(a == d)  # True（集合无序）

# 应用：检查权限
user_permissions = {'read', 'write'}
required_permissions = {'read'}
if required_permissions <= user_permissions:
    print("有权限")
```

---

### 第62题：frozenset

**问题**：不可变集合frozenset

**答案**：
```python
# 创建不可变集合
fs = frozenset([1, 2, 3, 4, 5])
print(fs)  # frozenset({1, 2, 3, 4, 5})

# 不能修改
# fs.add(6)  # AttributeError

# 可以作为字典的键
d = {
    frozenset([1, 2]): 'a',
    frozenset([3, 4]): 'b'
}

# 可以作为集合的元素
s = {frozenset([1, 2]), frozenset([3, 4])}

# 支持集合运算
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([3, 4, 5])
print(fs1 | fs2)  # frozenset({1, 2, 3, 4, 5})

# 性能稍好（不可变）
# 用于需要不可变集合的场景
```

---

### 第63题：集合推导式

**问题**：集合推导式的使用

**答案**：
```python
# 基本形式
squares = {x**2 for x in range(10)}
print(squares)  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 带条件
even_squares = {x**2 for x in range(10) if x % 2 == 0}

# 去重
text = "hello world"
unique_chars = {c.lower() for c in text if c.isalpha()}
print(unique_chars)  # {'h', 'e', 'l', 'o', 'w', 'r', 'd'}

# 展平并去重
lists = [[1, 2, 2], [3, 4], [4, 5, 5]]
unique = {num for lst in lists for num in lst}
print(unique)  # {1, 2, 3, 4, 5}

# 实际应用：找出所有不同的单词
text = "The quick brown fox jumps over the lazy dog"
words = {word.lower() for word in text.split()}
```

---

### 第64题：集合的实际应用

**问题**：集合在实际编程中的应用场景

**答案**：
```python
# 1. 去重
nums = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
unique_nums = list(set(nums))

# 2. 查找交集（共同好友）
alice_friends = {'Bob', 'Charlie', 'David'}
bob_friends = {'Alice', 'Charlie', 'Eve'}
common = alice_friends & bob_friends
print(common)  # {'Charlie'}

# 3. 查找差异（推荐新朋友）
suggestions = bob_friends - alice_friends - {'Alice'}
print(suggestions)  # {'Eve'}

# 4. 快速成员检查（O(1)）
valid_users = {'alice', 'bob', 'charlie'}
if 'alice' in valid_users:  # 很快
    print("有效用户")

# 5. 统计唯一访问者
visitors = ['alice', 'bob', 'alice', 'charlie', 'bob']
unique_visitors = len(set(visitors))
print(unique_visitors)  # 3

# 6. 找出列表中的重复元素
nums = [1, 2, 3, 2, 4, 5, 5]
seen = set()
duplicates = set()
for num in nums:
    if num in seen:
        duplicates.add(num)
    seen.add(num)
print(duplicates)  # {2, 5}

# 7. 过滤黑名单
all_users = {'alice', 'bob', 'charlie', 'david'}
blacklist = {'bob', 'david'}
valid_users = all_users - blacklist
print(valid_users)  # {'alice', 'charlie'}
```

---

### 第65题：集合性能优势

**问题**：集合相比列表的性能优势

**答案**：
```python
import timeit

# 成员检查：set O(1) vs list O(n)
big_list = list(range(10000))
big_set = set(range(10000))

# 列表查找（慢）
def list_lookup():
    return 9999 in big_list

# 集合查找（快）
def set_lookup():
    return 9999 in big_set

print(timeit.timeit(list_lookup, number=10000))  # 慢
print(timeit.timeit(set_lookup, number=10000))   # 快得多

# 去重：set比循环快
def remove_dup_list(lst):
    result = []
    for item in lst:
        if item not in result:
            result.append(item)
    return result

def remove_dup_set(lst):
    return list(set(lst))

nums = list(range(1000)) * 2
print(timeit.timeit(lambda: remove_dup_list(nums), number=100))
print(timeit.timeit(lambda: remove_dup_set(nums), number=100))

# 何时使用set：
# 1. 需要快速成员检查
# 2. 需要去重
# 3. 需要集合运算
# 4. 不需要保持顺序
# 5. 元素可哈希
```

---

## 学习笔记

在这里记录你的学习心得和遇到的问题：

```
日期：

重点知识：

易错点：

实践心得：
```

---

## 进度跟踪

完成题目：0/35

**列表（12题）**
- [ ] 第31题 - [ ] 第32题 - [ ] 第33题 - [ ] 第34题 - [ ] 第35题
- [ ] 第36题 - [ ] 第37题 - [ ] 第38题 - [ ] 第39题 - [ ] 第40题
- [ ] 第41题 - [ ] 第42题

**元组（6题）**
- [ ] 第43题 - [ ] 第44题 - [ ] 第45题 - [ ] 第46题 - [ ] 第47题
- [ ] 第48题

**字典（10题）**
- [ ] 第49题 - [ ] 第50题 - [ ] 第51题 - [ ] 第52题 - [ ] 第53题
- [ ] 第54题 - [ ] 第55题 - [ ] 第56题 - [ ] 第57题 - [ ] 第58题

**集合（7题）**
- [ ] 第59题 - [ ] 第60题 - [ ] 第61题 - [ ] 第62题 - [ ] 第63题
- [ ] 第64题 - [ ] 第65题
