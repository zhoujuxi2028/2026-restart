# 10 - 迭代器与生成器（20题）

## 难度分布
- 简单：8题
- 中等：8题
- 困难：4题

---

## 第201题：迭代器基础

**问题**：理解Python迭代器协议

**答案**：
```python
# 可迭代对象vs迭代器
# 可迭代对象：实现__iter__()
# 迭代器：实现__iter__()和__next__()

# 列表是可迭代对象
lst = [1, 2, 3]

# 获取迭代器
iterator = iter(lst)

# 使用next()获取元素
print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3
# print(next(iterator))  # StopIteration

# 自定义迭代器
class Counter:
    def __init__(self, max_num):
        self.max_num = max_num
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.max_num:
            raise StopIteration
        self.current += 1
        return self.current

counter = Counter(5)
for num in counter:
    print(num)  # 1, 2, 3, 4, 5

# 可迭代对象（每次返回新迭代器）
class MyRange:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        return MyRangeIterator(self.start, self.end)

class MyRangeIterator:
    def __init__(self, start, end):
        self.current = start
        self.end = end

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.end:
            raise StopIteration
        value = self.current
        self.current += 1
        return value

# 可以多次迭代
r = MyRange(1, 4)
print(list(r))  # [1, 2, 3]
print(list(r))  # [1, 2, 3]
```

---

## 第202题：生成器基础

**问题**：使用yield创建生成器

**答案**：
```python
# 生成器函数
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3

# 生成器是一次性的
gen = simple_generator()
print(list(gen))  # [1, 2, 3]
print(list(gen))  # []

# 带参数的生成器
def countdown(n):
    while n > 0:
        yield n
        n -= 1

for i in countdown(5):
    print(i)  # 5, 4, 3, 2, 1

# 无限生成器
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1

gen = infinite_sequence()
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 2

# 斐波那契生成器
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()
for i in range(10):
    print(next(fib))  # 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

---

## 第203题：生成器表达式

**问题**：使用生成器表达式

**答案**：
```python
# 生成器表达式（类似列表推导式）
gen = (x**2 for x in range(10))
print(next(gen))  # 0
print(next(gen))  # 1
print(list(gen))  # [4, 9, 16, 25, 36, 49, 64, 81]

# 与列表推导式对比
list_comp = [x**2 for x in range(10)]  # 立即计算，占用内存
gen_expr = (x**2 for x in range(10))   # 惰性计算，节省内存

# 内存效率
import sys
list_size = sys.getsizeof([x for x in range(10000)])
gen_size = sys.getsizeof((x for x in range(10000)))
print(f"列表: {list_size}字节")
print(f"生成器: {gen_size}字节")

# 过滤
even_squares = (x**2 for x in range(10) if x % 2 == 0)
print(list(even_squares))  # [0, 4, 16, 36, 64]

# 嵌套
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = (item for row in matrix for item in row)
print(list(flat))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 实际应用
def read_large_file(file_path):
    with open(file_path) as f:
        return (line.strip() for line in f)

# 内存高效的数据处理
numbers = (int(line) for line in read_large_file('numbers.txt'))
squares = (n**2 for n in numbers if n > 0)
total = sum(squares)
```

---

## 第204题：yield from

**问题**：使用yield from委托生成器

**答案**：
```python
# 基本用法
def generator1():
    yield 1
    yield 2

def generator2():
    yield 3
    yield 4

def combined():
    yield from generator1()
    yield from generator2()

print(list(combined()))  # [1, 2, 3, 4]

# 等价于
def combined_manual():
    for item in generator1():
        yield item
    for item in generator2():
        yield item

# 递归生成器
def flatten(nested_list):
    for item in nested_list:
        if isinstance(item, list):
            yield from flatten(item)
        else:
            yield item

nested = [1, [2, 3, [4, 5]], 6, [7, [8, 9]]]
print(list(flatten(nested)))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 生成器链
def read_files(file_list):
    for file_path in file_list:
        yield from read_file(file_path)

def read_file(file_path):
    with open(file_path) as f:
        yield from f

# 委托到另一个生成器
def generator_wrapper():
    result = yield from some_generator()
    return result
```

---

## 第205题：生成器的send方法

**问题**：使用send()向生成器发送值

**答案**：
```python
# 基本send用法
def echo_generator():
    while True:
        received = yield
        print(f"接收到: {received}")

gen = echo_generator()
next(gen)  # 启动生成器
gen.send("Hello")  # 接收到: Hello
gen.send("World")  # 接收到: World

# 双向通信
def accumulator():
    total = 0
    while True:
        value = yield total
        if value is not None:
            total += value

acc = accumulator()
next(acc)  # 启动
print(acc.send(1))  # 1
print(acc.send(2))  # 3
print(acc.send(3))  # 6

# 协程示例
def averager():
    total = 0
    count = 0
    average = None
    while True:
        term = yield average
        if term is None:
            break
        total += term
        count += 1
        average = total / count

avg = averager()
next(avg)  # 预激协程
print(avg.send(10))  # 10.0
print(avg.send(20))  # 15.0
print(avg.send(30))  # 20.0

# 实际应用：状态机
def state_machine():
    state = 'START'
    while True:
        if state == 'START':
            action = yield 'Ready'
            state = 'PROCESS' if action == 'start' else 'START'
        elif state == 'PROCESS':
            action = yield 'Processing'
            state = 'END' if action == 'finish' else 'PROCESS'
        elif state == 'END':
            action = yield 'Done'
            state = 'START' if action == 'reset' else 'END'

machine = state_machine()
print(next(machine))  # Ready
print(machine.send('start'))  # Processing
print(machine.send('finish'))  # Done
```

---

## 第206题：生成器的close和throw

**问题**：使用close()和throw()控制生成器

**答案**：
```python
# close() - 关闭生成器
def generator():
    try:
        yield 1
        yield 2
        yield 3
    finally:
        print("清理资源")

gen = generator()
print(next(gen))  # 1
gen.close()  # 清理资源
# print(next(gen))  # StopIteration

# throw() - 向生成器抛出异常
def error_handling_generator():
    while True:
        try:
            value = yield
            print(f"处理: {value}")
        except ValueError as e:
            print(f"处理错误: {e}")
        except Exception as e:
            print(f"未知错误: {e}")
            break

gen = error_handling_generator()
next(gen)
gen.send(10)  # 处理: 10
gen.throw(ValueError, "错误值")  # 处理错误: 错误值
gen.send(20)  # 处理: 20

# 异常处理
def robust_generator():
    try:
        while True:
            try:
                value = yield
                # 处理value
            except ValueError:
                print("ValueError被捕获")
    finally:
        print("生成器关闭")

# 实际应用：上下文管理器
from contextlib import contextmanager

@contextmanager
def managed_resource():
    print("获取资源")
    try:
        yield "resource"
    finally:
        print("释放资源")

with managed_resource() as resource:
    print(f"使用{resource}")
```

---

## 第207题：itertools模块基础

**问题**：使用itertools创建迭代器

**答案**：
```python
import itertools

# count() - 无限计数
for i in itertools.count(10, 2):
    if i > 20:
        break
    print(i)  # 10, 12, 14, 16, 18, 20

# cycle() - 循环迭代
colors = itertools.cycle(['red', 'green', 'blue'])
for i, color in enumerate(colors):
    if i >= 6:
        break
    print(color)  # red, green, blue, red, green, blue

# repeat() - 重复元素
for x in itertools.repeat('Hello', 3):
    print(x)  # Hello Hello Hello

# chain() - 连接迭代器
chain = itertools.chain([1, 2, 3], ['a', 'b', 'c'])
print(list(chain))  # [1, 2, 3, 'a', 'b', 'c']

# compress() - 根据选择器过滤
data = ['A', 'B', 'C', 'D']
selectors = [1, 0, 1, 0]
result = itertools.compress(data, selectors)
print(list(result))  # ['A', 'C']

# dropwhile() - 丢弃元素直到条件为False
data = [1, 4, 6, 4, 1]
result = itertools.dropwhile(lambda x: x < 5, data)
print(list(result))  # [6, 4, 1]

# takewhile() - 获取元素直到条件为False
result = itertools.takewhile(lambda x: x < 5, data)
print(list(result))  # [1, 4]

# islice() - 切片迭代器
result = itertools.islice(range(10), 2, 8, 2)
print(list(result))  # [2, 4, 6]
```

---

## 第208题：itertools组合迭代器

**问题**：使用itertools进行组合运算

**答案**：
```python
import itertools

# product() - 笛卡尔积
result = itertools.product([1, 2], ['a', 'b'])
print(list(result))  # [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]

# 多个迭代器
result = itertools.product([1, 2], [3, 4], [5, 6])
print(list(result))  # [(1, 3, 5), (1, 3, 6), ...]

# repeat参数
result = itertools.product([0, 1], repeat=3)
print(list(result))  # [(0,0,0), (0,0,1), ..., (1,1,1)]

# permutations() - 排列
result = itertools.permutations([1, 2, 3])
print(list(result))  # [(1,2,3), (1,3,2), (2,1,3), ...]

# 指定长度
result = itertools.permutations([1, 2, 3], 2)
print(list(result))  # [(1,2), (1,3), (2,1), (2,3), (3,1), (3,2)]

# combinations() - 组合
result = itertools.combinations([1, 2, 3], 2)
print(list(result))  # [(1,2), (1,3), (2,3)]

# combinations_with_replacement() - 允许重复的组合
result = itertools.combinations_with_replacement([1, 2, 3], 2)
print(list(result))  # [(1,1), (1,2), (1,3), (2,2), (2,3), (3,3)]

# 实际应用：密码生成
import string

def generate_passwords(length=4):
    chars = string.ascii_lowercase
    for password in itertools.product(chars, repeat=length):
        yield ''.join(password)

passwords = generate_passwords(2)
for i, pwd in enumerate(passwords):
    if i >= 10:
        break
    print(pwd)
```

---

## 第209题：itertools分组和累积

**问题**：使用itertools进行分组和累积操作

**答案**：
```python
import itertools

# groupby() - 分组
data = ['A', 'A', 'B', 'B', 'B', 'C', 'A']
for key, group in itertools.groupby(data):
    print(f"{key}: {list(group)}")

# 按条件分组
data = [1, 4, 6, 4, 1, 8, 2]
for key, group in itertools.groupby(data, lambda x: x > 3):
    print(f"{key}: {list(group)}")

# 分组前需要排序
people = [
    {'name': 'Alice', 'age': 25},
    {'name': 'Bob', 'age': 30},
    {'name': 'Charlie', 'age': 25},
]

# 按年龄分组
people.sort(key=lambda x: x['age'])
for age, group in itertools.groupby(people, lambda x: x['age']):
    print(f"Age {age}: {[p['name'] for p in group]}")

# accumulate() - 累积
import operator

# 累加
data = [1, 2, 3, 4, 5]
result = itertools.accumulate(data)
print(list(result))  # [1, 3, 6, 10, 15]

# 累乘
result = itertools.accumulate(data, operator.mul)
print(list(result))  # [1, 2, 6, 24, 120]

# 最大值累积
data = [5, 2, 8, 1, 9, 3]
result = itertools.accumulate(data, max)
print(list(result))  # [5, 5, 8, 8, 9, 9]

# 自定义函数
data = [1, 2, 3, 4]
result = itertools.accumulate(data, lambda x, y: x**2 + y)
print(list(result))  # [1, 3, 12, 148]
```

---

## 第210题：自定义高级迭代器

**问题**：创建复杂的自定义迭代器

**答案**：
```python
# 双向迭代器
class BiDirectionalIterator:
    def __init__(self, data):
        self.data = list(data)
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        value = self.data[self.index]
        self.index += 1
        return value

    def __reversed__(self):
        return reversed(self.data)

    def prev(self):
        if self.index > 0:
            self.index -= 1
            return self.data[self.index]
        raise StopIteration

# 带缓存的迭代器
class CachedIterator:
    def __init__(self, iterable):
        self.iterable = iter(iterable)
        self.cache = []
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index < len(self.cache):
            value = self.cache[self.index]
            self.index += 1
            return value

        value = next(self.iterable)
        self.cache.append(value)
        self.index += 1
        return value

    def reset(self):
        self.index = 0

# 窗口迭代器
class WindowIterator:
    def __init__(self, iterable, window_size):
        self.iterable = list(iterable)
        self.window_size = window_size
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index + self.window_size > len(self.iterable):
            raise StopIteration

        window = self.iterable[self.index:self.index + self.window_size]
        self.index += 1
        return window

# 使用
data = [1, 2, 3, 4, 5]
windows = WindowIterator(data, 3)
for window in windows:
    print(window)  # [1,2,3], [2,3,4], [3,4,5]

# 分块迭代器
def chunked(iterable, n):
    iterator = iter(iterable)
    while True:
        chunk = list(itertools.islice(iterator, n))
        if not chunk:
            break
        yield chunk

for chunk in chunked(range(10), 3):
    print(chunk)  # [0,1,2], [3,4,5], [6,7,8], [9]
```

---

由于响应长度限制，我会继续创建剩余题目。让我快速完成这个文件和其他文件：

<function_calls>
<invoke name="Bash">
<parameter name="command">cd "/Users/michael_zhou/Documents/GitHub/2026-restart/Python-Interview-300" && wc -l *.md | tail -1