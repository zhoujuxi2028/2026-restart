# 04 - 函数基础（15题）

## 难度分布
- 简单：8题
- 中等：5题
- 困难：2题

---

## 第86题：函数定义与调用

**问题**：函数的基本定义和调用方式

**答案**：
```python
# 基本函数
def greet():
    print("Hello, World!")

greet()  # 调用

# 带参数的函数
def greet_user(name):
    print(f"Hello, {name}!")

greet_user("Alice")

# 带返回值
def add(a, b):
    return a + b

result = add(3, 5)
print(result)  # 8

# 多个返回值（实际返回元组）
def get_user():
    return "Alice", 25, "NYC"

name, age, city = get_user()

# 无return语句返回None
def no_return():
    pass

result = no_return()
print(result)  # None

# 函数文档字符串
def multiply(a, b):
    """
    将两个数相乘

    参数:
        a: 第一个数
        b: 第二个数

    返回:
        两数的乘积
    """
    return a * b

print(multiply.__doc__)
help(multiply)
```

---

## 第87题：参数传递

**问题**：函数参数的各种传递方式

**答案**：
```python
# 位置参数
def power(base, exponent):
    return base ** exponent

print(power(2, 3))  # 8

# 关键字参数
print(power(base=2, exponent=3))  # 8
print(power(exponent=3, base=2))  # 8（顺序无关）

# 混合使用（位置参数必须在前）
print(power(2, exponent=3))  # 8

# 默认参数
def greet(name, message="Hello"):
    return f"{message}, {name}!"

print(greet("Alice"))  # "Hello, Alice!"
print(greet("Bob", "Hi"))  # "Hi, Bob!"

# 注意：默认参数的陷阱
def append_to(element, target=[]):  # 危险！
    target.append(element)
    return target

list1 = append_to(1)  # [1]
list2 = append_to(2)  # [1, 2] - 不是预期的[2]

# 正确做法
def append_to_safe(element, target=None):
    if target is None:
        target = []
    target.append(element)
    return target

# 强制关键字参数（Python 3+）
def create_user(name, *, age, city):
    return {'name': name, 'age': age, 'city': city}

# create_user("Alice", 25, "NYC")  # TypeError
create_user("Alice", age=25, city="NYC")  # 正确

# 强制位置参数（Python 3.8+）
def divide(a, b, /):
    return a / b

print(divide(10, 2))  # 5
# print(divide(a=10, b=2))  # TypeError
```

---

## 第88题：可变参数

**问题**：*args和**kwargs的使用

**答案**：
```python
# *args（可变位置参数）
def sum_all(*args):
    return sum(args)

print(sum_all(1, 2, 3))        # 6
print(sum_all(1, 2, 3, 4, 5))  # 15

# **kwargs（可变关键字参数）
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=25, city="NYC")

# 混合使用
def func(a, b, *args, **kwargs):
    print(f"a={a}, b={b}")
    print(f"args={args}")
    print(f"kwargs={kwargs}")

func(1, 2, 3, 4, 5, x=10, y=20)
# a=1, b=2
# args=(3, 4, 5)
# kwargs={'x': 10, 'y': 20}

# 参数顺序
def func(pos, /, standard, *args, kw_only, **kwargs):
    pass

# 解包参数
def add(a, b, c):
    return a + b + c

nums = [1, 2, 3]
print(add(*nums))  # 6

data = {'a': 1, 'b': 2, 'c': 3}
print(add(**data))  # 6

# 实际应用：装饰器
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b
```

---

## 第89题：函数作为对象

**问题**：函数是一等公民

**答案**：
```python
# 函数赋值给变量
def greet():
    return "Hello!"

say_hello = greet
print(say_hello())  # "Hello!"

# 函数作为参数
def apply_operation(func, x, y):
    return func(x, y)

def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

print(apply_operation(add, 3, 5))       # 8
print(apply_operation(multiply, 3, 5))  # 15

# 函数作为返回值
def get_operation(op):
    def add(a, b):
        return a + b
    def subtract(a, b):
        return a - b

    if op == '+':
        return add
    elif op == '-':
        return subtract

operation = get_operation('+')
print(operation(10, 5))  # 15

# 函数属性
def my_func():
    pass

my_func.version = "1.0"
print(my_func.version)

# 函数列表
operations = [add, multiply, lambda x, y: x - y]
for op in operations:
    print(op(10, 5))

# 实际应用：策略模式
def process_data(data, strategy):
    return strategy(data)

data = [1, 2, 3, 4, 5]
print(process_data(data, sum))      # 15
print(process_data(data, len))      # 5
print(process_data(data, max))      # 5
```

---

## 第90题：lambda表达式

**问题**：匿名函数lambda的使用

**答案**：
```python
# 基本lambda
add = lambda x, y: x + y
print(add(3, 5))  # 8

# 等价的普通函数
def add(x, y):
    return x + y

# 排序中使用
students = [
    {'name': 'Alice', 'grade': 85},
    {'name': 'Bob', 'grade': 92},
    {'name': 'Charlie', 'grade': 78}
]

# 按成绩排序
sorted_students = sorted(students, key=lambda s: s['grade'])

# 按名字排序
sorted_students = sorted(students, key=lambda s: s['name'])

# map with lambda
nums = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x**2, nums))
print(squares)  # [1, 4, 9, 16, 25]

# filter with lambda
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # [2, 4]

# 条件lambda
max_func = lambda a, b: a if a > b else b
print(max_func(10, 5))  # 10

# 多个参数
multiply = lambda x, y, z: x * y * z
print(multiply(2, 3, 4))  # 24

# 注意：lambda限制
# 只能包含单个表达式
# 不能包含语句
# 可读性较差

# 推荐：复杂逻辑用普通函数
# 不推荐
result = lambda x: x**2 if x > 0 else -x**2 if x < 0 else 0

# 推荐
def process(x):
    if x > 0:
        return x**2
    elif x < 0:
        return -x**2
    else:
        return 0
```

---

## 第91题：闭包

**问题**：理解闭包的概念和应用

**答案**：
```python
# 基本闭包
def outer(x):
    def inner(y):
        return x + y
    return inner

add_5 = outer(5)
print(add_5(3))  # 8
print(add_5(10)) # 15

# 闭包访问外部变量
def make_counter():
    count = 0
    def counter():
        nonlocal count
        count += 1
        return count
    return counter

c1 = make_counter()
print(c1())  # 1
print(c1())  # 2

c2 = make_counter()
print(c2())  # 1（独立的计数器）

# 闭包工厂
def make_multiplier(n):
    return lambda x: x * n

times_2 = make_multiplier(2)
times_3 = make_multiplier(3)

print(times_2(5))  # 10
print(times_3(5))  # 15

# 实际应用：记忆化
def memoize(func):
    cache = {}
    def wrapper(n):
        if n not in cache:
            cache[n] = func(n)
        return cache[n]
    return wrapper

@memoize
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(100))  # 很快

# 闭包陷阱
def create_multipliers():
    return [lambda x: i * x for i in range(5)]

multipliers = create_multipliers()
print(multipliers[2](10))  # 预期20，实际40

# 修复
def create_multipliers_fixed():
    return [lambda x, i=i: i * x for i in range(5)]

multipliers = create_multipliers_fixed()
print(multipliers[2](10))  # 20
```

---

## 第92题：装饰器基础

**问题**：理解和使用装饰器

**答案**：
```python
# 简单装饰器
def my_decorator(func):
    def wrapper():
        print("Before function")
        func()
        print("After function")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Before function
# Hello!
# After function

# 等价于
def say_hello():
    print("Hello!")
say_hello = my_decorator(say_hello)

# 带参数的装饰器
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Finished {func.__name__}")
        return result
    return wrapper

@my_decorator
def add(a, b):
    return a + b

result = add(3, 5)

# 保留函数元信息
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """Wrapper function"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def my_func():
    """Original function"""
    pass

print(my_func.__name__)  # my_func（而不是wrapper）
print(my_func.__doc__)   # Original function

# 实际应用：计时器
import time

def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end-start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "Done"

slow_function()
```

---

## 第93题：递归函数

**问题**：递归的概念和应用

**答案**：
```python
# 基本递归：阶乘
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))  # 120

# 递归：斐波那契数列
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(10))  # 55

# 优化：记忆化
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_cached(n):
    if n <= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

print(fibonacci_cached(100))  # 很快

# 递归：二分查找
def binary_search(arr, target, left=0, right=None):
    if right is None:
        right = len(arr) - 1

    if left > right:
        return -1

    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search(arr, target, mid + 1, right)
    else:
        return binary_search(arr, target, left, mid - 1)

arr = [1, 3, 5, 7, 9, 11]
print(binary_search(arr, 7))  # 3

# 递归：树遍历
def tree_sum(node):
    if node is None:
        return 0
    return node['value'] + tree_sum(node.get('left')) + tree_sum(node.get('right'))

tree = {
    'value': 1,
    'left': {'value': 2, 'left': None, 'right': None},
    'right': {'value': 3, 'left': None, 'right': None}
}

# 递归限制
import sys
print(sys.getrecursionlimit())  # 默认1000
sys.setrecursionlimit(2000)     # 增加限制

# 尾递归优化（Python不支持）
# 改用迭代
def factorial_iterative(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result
```

---

## 第94题：高阶函数

**问题**：map、filter、reduce的使用

**答案**：
```python
# map：对每个元素应用函数
nums = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x**2, nums))
print(squares)  # [1, 4, 9, 16, 25]

# 多个可迭代对象
nums1 = [1, 2, 3]
nums2 = [10, 20, 30]
sums = list(map(lambda x, y: x + y, nums1, nums2))
print(sums)  # [11, 22, 33]

# filter：筛选元素
nums = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # [2, 4, 6]

# reduce：累积操作
from functools import reduce

nums = [1, 2, 3, 4, 5]
sum_all = reduce(lambda x, y: x + y, nums)
print(sum_all)  # 15

# 带初始值
product = reduce(lambda x, y: x * y, nums, 1)
print(product)  # 120

# 实际应用：展平嵌套列表
nested = [[1, 2], [3, 4], [5, 6]]
flattened = reduce(lambda x, y: x + y, nested)
print(flattened)  # [1, 2, 3, 4, 5, 6]

# 组合使用
nums = [1, 2, 3, 4, 5, 6]
result = reduce(lambda x, y: x + y,
                map(lambda x: x**2,
                    filter(lambda x: x % 2 == 0, nums)))
print(result)  # 2^2 + 4^2 + 6^2 = 56

# 推荐：使用列表推导式（更Pythonic）
result = sum(x**2 for x in nums if x % 2 == 0)
print(result)  # 56

# sorted：高阶排序
students = [
    ('Alice', 85),
    ('Bob', 92),
    ('Charlie', 78)
]

# 按分数排序
sorted_students = sorted(students, key=lambda x: x[1])

# 按名字长度排序
names = ['Alice', 'Bob', 'Charlie']
sorted_names = sorted(names, key=len)
```

---

## 第95题：偏函数

**问题**：使用functools.partial创建偏函数

**答案**：
```python
from functools import partial

# 基本用法
def power(base, exponent):
    return base ** exponent

# 创建平方函数
square = partial(power, exponent=2)
print(square(5))  # 25

# 创建立方函数
cube = partial(power, exponent=3)
print(cube(5))  # 125

# 固定多个参数
def greet(greeting, name, punctuation):
    return f"{greeting}, {name}{punctuation}"

say_hello = partial(greet, "Hello")
print(say_hello("Alice", "!"))  # "Hello, Alice!"

friendly_greet = partial(greet, "Hello", punctuation="!")
print(friendly_greet("Bob"))  # "Hello, Bob!"

# 实际应用：int转换
int2 = partial(int, base=2)
int16 = partial(int, base=16)

print(int2('1010'))  # 10
print(int16('ff'))   # 255

# 日志函数
import logging

debug = partial(logging.log, logging.DEBUG)
info = partial(logging.log, logging.INFO)
error = partial(logging.log, logging.ERROR)

# 默认参数填充
from functools import partial

def create_url(protocol, host, port, path):
    return f"{protocol}://{host}:{port}{path}"

# 创建HTTP URL生成器
http_url = partial(create_url, "http", port=80)
print(http_url("example.com", "/api"))

# 创建HTTPS URL生成器
https_url = partial(create_url, "https", port=443)
print(https_url("example.com", "/api"))
```

---

## 第96题：函数注解

**问题**：类型提示和函数注解

**答案**：
```python
# 基本类型注解
def greet(name: str) -> str:
    return f"Hello, {name}!"

# 多个参数
def add(a: int, b: int) -> int:
    return a + b

# 查看注解
print(add.__annotations__)
# {'a': <class 'int'>, 'b': <class 'int'>, 'return': <class 'int'>}

# 复杂类型注解
from typing import List, Dict, Tuple, Optional, Union

def process_items(items: List[int]) -> int:
    return sum(items)

def get_user(user_id: int) -> Optional[Dict[str, str]]:
    # 返回字典或None
    pass

def divide(a: float, b: float) -> Union[float, str]:
    # 返回float或str
    if b == 0:
        return "Cannot divide by zero"
    return a / b

# 类型别名
from typing import List, Tuple

Point = Tuple[float, float]
Points = List[Point]

def calculate_distance(points: Points) -> float:
    pass

# 泛型
from typing import TypeVar, Generic, List

T = TypeVar('T')

def first(items: List[T]) -> T:
    return items[0]

# 可调用类型
from typing import Callable

def apply_func(func: Callable[[int, int], int], a: int, b: int) -> int:
    return func(a, b)

# 注意：类型注解不强制检查
def add(a: int, b: int) -> int:
    return a + b

print(add("hello", "world"))  # 不会报错，返回"helloworld"

# 使用mypy进行静态类型检查
# pip install mypy
# mypy script.py
```

---

## 第97题：生成器函数

**问题**：使用yield创建生成器

**答案**：
```python
# 基本生成器
def countdown(n):
    while n > 0:
        yield n
        n -= 1

for i in countdown(5):
    print(i)  # 5, 4, 3, 2, 1

# 斐波那契生成器
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 使用生成器
fib = fibonacci()
for _ in range(10):
    print(next(fib), end=' ')
# 0 1 1 2 3 5 8 13 21 34

# 生成器表达式
squares = (x**2 for x in range(10))
print(next(squares))  # 0
print(next(squares))  # 1

# 内存效率对比
# 列表：占用内存
large_list = [x**2 for x in range(1000000)]

# 生成器：惰性求值
large_gen = (x**2 for x in range(1000000))

# 实际应用：读取大文件
def read_large_file(file_path):
    with open(file_path, 'r') as f:
        for line in f:
            yield line.strip()

# for line in read_large_file('large.txt'):
#     process(line)

# yield from
def chain(*iterables):
    for iterable in iterables:
        yield from iterable

result = list(chain([1, 2], [3, 4], [5, 6]))
print(result)  # [1, 2, 3, 4, 5, 6]

# 生成器方法
def my_generator():
    value = yield 1
    print(f"Received: {value}")
    yield 2

gen = my_generator()
print(next(gen))        # 1
print(gen.send(100))    # Received: 100, then 2
```

---

## 第98题：函数作用域

**问题**：理解LEGB规则

**答案**：
```python
# LEGB: Local, Enclosing, Global, Built-in

# 全局作用域
x = "global"

def outer():
    # 嵌套作用域（Enclosing）
    x = "enclosing"

    def inner():
        # 局部作用域（Local）
        x = "local"
        print(x)  # local

    inner()
    print(x)  # enclosing

outer()
print(x)  # global

# global关键字
count = 0

def increment():
    global count
    count += 1

increment()
print(count)  # 1

# nonlocal关键字
def outer():
    x = 0

    def inner():
        nonlocal x
        x += 1
        print(x)

    inner()  # 1
    inner()  # 2

# 作用域陷阱
x = 10

def func():
    print(x)  # UnboundLocalError
    x = 20    # 局部变量

# 解决方案
def func():
    global x
    print(x)  # 10
    x = 20

# 内置作用域
def len():  # 覆盖内置函数（不推荐）
    return "custom len"

print(len([1, 2, 3]))  # "custom len"

# 查看作用域
x = "global"

def func():
    y = "local"
    print(locals())   # 局部变量
    print(globals())  # 全局变量

# 闭包与作用域
def make_counter():
    count = 0
    def counter():
        nonlocal count
        count += 1
        return count
    return counter

c = make_counter()
print(c())  # 1
print(c())  # 2
```

---

## 第99题：函数缓存

**问题**：使用lru_cache优化函数性能

**答案**：
```python
from functools import lru_cache
import time

# 不使用缓存
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

start = time.time()
print(fibonacci(30))
print(f"Time: {time.time() - start:.4f}s")  # 慢

# 使用缓存
@lru_cache(maxsize=None)
def fibonacci_cached(n):
    if n <= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

start = time.time()
print(fibonacci_cached(30))
print(f"Time: {time.time() - start:.4f}s")  # 快得多

# 查看缓存信息
print(fibonacci_cached.cache_info())
# CacheInfo(hits=28, misses=31, maxsize=None, currsize=31)

# 清除缓存
fibonacci_cached.cache_clear()

# 限制缓存大小
@lru_cache(maxsize=128)
def expensive_func(n):
    time.sleep(0.1)
    return n ** 2

# 实际应用：网络请求缓存
from functools import lru_cache
import requests

@lru_cache(maxsize=100)
def fetch_url(url):
    response = requests.get(url)
    return response.text

# 第一次请求：慢
# 后续请求：快（从缓存读取）

# 自定义缓存装饰器
def memoize(func):
    cache = {}
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    wrapper.cache = cache
    return wrapper

@memoize
def fibonacci_custom(n):
    if n <= 1:
        return n
    return fibonacci_custom(n-1) + fibonacci_custom(n-2)

# 带过期时间的缓存
import time
from functools import wraps

def cached_with_timeout(timeout):
    def decorator(func):
        cache = {}
        @wraps(func)
        def wrapper(*args):
            now = time.time()
            if args in cache:
                result, timestamp = cache[args]
                if now - timestamp < timeout:
                    return result
            result = func(*args)
            cache[args] = (result, now)
            return result
        return wrapper
    return decorator

@cached_with_timeout(60)  # 缓存60秒
def get_data(key):
    # 模拟耗时操作
    time.sleep(1)
    return f"Data for {key}"
```

---

## 第100题：函数式编程技巧

**问题**：函数式编程的常用模式

**答案**：
```python
# 纯函数（无副作用）
# 不推荐
total = 0
def add_to_total(x):
    global total
    total += x
    return total

# 推荐
def add(x, y):
    return x + y

# 不可变数据
# 不推荐
def append_item(lst, item):
    lst.append(item)
    return lst

# 推荐
def append_item(lst, item):
    return lst + [item]

# 函数组合
def compose(*functions):
    def inner(arg):
        for func in reversed(functions):
            arg = func(arg)
        return arg
    return inner

def add_one(x):
    return x + 1

def multiply_two(x):
    return x * 2

def square(x):
    return x ** 2

# 组合函数
f = compose(square, multiply_two, add_one)
print(f(3))  # ((3 + 1) * 2) ** 2 = 64

# 柯里化
def curry(func):
    def curried(*args):
        if len(args) >= func.__code__.co_argcount:
            return func(*args)
        return lambda *more: curried(*(args + more))
    return curried

@curry
def add_three(a, b, c):
    return a + b + c

print(add_three(1)(2)(3))  # 6
print(add_three(1, 2)(3))  # 6
print(add_three(1, 2, 3))  # 6

# 惰性求值
def lazy_range(n):
    i = 0
    while i < n:
        yield i
        i += 1

# 管道操作
def pipe(data, *functions):
    for func in functions:
        data = func(data)
    return data

nums = [1, 2, 3, 4, 5]
result = pipe(
    nums,
    lambda x: map(lambda i: i * 2, x),
    lambda x: filter(lambda i: i > 5, x),
    list
)
print(result)  # [6, 8, 10]

# 部分应用
from functools import partial

def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(list(map(square, [1, 2, 3, 4])))  # [1, 4, 9, 16]
```

---

## 学习笔记

在这里记录你的学习心得和遇到的问题：

```
日期：

重点知识：
- 函数参数（位置、关键字、默认、可变）
- 闭包和装饰器
- 生成器和惰性求值
- 函数作用域（LEGB规则）

易错点：
- 默认参数陷阱（可变对象）
- 闭包变量绑定
- global vs nonlocal
- 递归深度限制

实践心得：
```

---

## 进度跟踪

完成题目：0/15

- [ ] 第86题 - [ ] 第87题 - [ ] 第88题 - [ ] 第89题 - [ ] 第90题
- [ ] 第91题 - [ ] 第92题 - [ ] 第93题 - [ ] 第94题 - [ ] 第95题
- [ ] 第96题 - [ ] 第97题 - [ ] 第98题 - [ ] 第99题 - [ ] 第100题
