# 07 - 异常处理（15题）

## 难度分布
- 简单：8题
- 中等：5题
- 困难：2题

---

## 第151题：基本异常处理

**问题**：try-except的基本用法

**答案**：
```python
# 基本try-except
try:
    x = 10 / 0
except ZeroDivisionError:
    print("不能除以零")

# 捕获多个异常
try:
    x = int("abc")
except (ValueError, TypeError):
    print("转换失败")

# 分别处理
try:
    result = 10 / int(input("输入数字: "))
except ZeroDivisionError:
    print("不能除以零")
except ValueError:
    print("输入无效")

# 捕获所有异常
try:
    risky_operation()
except Exception as e:
    print(f"发生错误: {e}")

# 获取异常信息
try:
    x = 1 / 0
except ZeroDivisionError as e:
    print(f"异常类型: {type(e).__name__}")
    print(f"异常信息: {e}")
    print(f"异常参数: {e.args}")
```

---

## 第152题：else和finally子句

**问题**：try-except-else-finally的完整结构

**答案**：
```python
# try-except-else-finally
def divide(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        print("除数不能为零")
    else:
        # 没有异常时执行
        print(f"结果: {result}")
        return result
    finally:
        # 总是执行
        print("操作完成")

# 文件处理示例
def read_file(filename):
    file = None
    try:
        file = open(filename, 'r')
        content = file.read()
        return content
    except FileNotFoundError:
        print(f"文件 {filename} 不存在")
    except PermissionError:
        print("没有权限读取文件")
    else:
        print("文件读取成功")
    finally:
        if file:
            file.close()
            print("文件已关闭")

# finally在return前执行
def test():
    try:
        return "try"
    finally:
        print("finally执行")
        # return "finally"  # 会覆盖try中的return

print(test())  # 先输出"finally执行"，再返回"try"
```

---

## 第153题：抛出异常

**问题**：使用raise抛出异常

**答案**：
```python
# 基本raise
def check_age(age):
    if age < 0:
        raise ValueError("年龄不能为负")
    if age > 150:
        raise ValueError("年龄过大")
    return age

try:
    check_age(-5)
except ValueError as e:
    print(e)

# 不带参数的raise（重新抛出）
def process_data():
    try:
        risky_operation()
    except Exception as e:
        print(f"记录错误: {e}")
        raise  # 重新抛出原异常

# raise from（异常链）
def convert_value(value):
    try:
        return int(value)
    except ValueError as e:
        raise TypeError(f"无法转换 {value}") from e

try:
    convert_value("abc")
except TypeError as e:
    print(f"异常: {e}")
    print(f"原因: {e.__cause__}")

# 抛出不同异常
def validate_email(email):
    if '@' not in email:
        raise ValueError("邮箱格式错误")
    if len(email) < 5:
        raise ValueError("邮箱太短")
```

---

## 第154题：自定义异常

**问题**：创建自定义异常类

**答案**：
```python
# 基本自定义异常
class CustomError(Exception):
    pass

raise CustomError("这是自定义异常")

# 带属性的异常
class ValidationError(Exception):
    def __init__(self, message, field):
        super().__init__(message)
        self.field = field

try:
    raise ValidationError("值无效", "email")
except ValidationError as e:
    print(f"字段 {e.field}: {e}")

# 异常层次结构
class DatabaseError(Exception):
    """数据库相关异常的基类"""
    pass

class ConnectionError(DatabaseError):
    """数据库连接异常"""
    pass

class QueryError(DatabaseError):
    """查询异常"""
    pass

class TransactionError(DatabaseError):
    """事务异常"""
    pass

# 使用
try:
    raise QueryError("SQL语法错误")
except DatabaseError as e:
    print(f"数据库错误: {e}")

# 带额外信息的异常
class HTTPError(Exception):
    def __init__(self, status_code, message):
        self.status_code = status_code
        self.message = message
        super().__init__(f"{status_code}: {message}")

try:
    raise HTTPError(404, "Not Found")
except HTTPError as e:
    print(f"HTTP错误 {e.status_code}: {e.message}")

# 实际应用：API异常
class APIException(Exception):
    def __init__(self, message, code=None, details=None):
        self.message = message
        self.code = code
        self.details = details
        super().__init__(self.message)

    def to_dict(self):
        return {
            'error': self.message,
            'code': self.code,
            'details': self.details
        }
```

---

## 第155题：异常的传播

**问题**：理解异常如何在调用栈中传播

**答案**：
```python
# 异常向上传播
def level3():
    print("Level 3")
    raise ValueError("Level 3错误")

def level2():
    print("Level 2")
    level3()

def level1():
    print("Level 1")
    level2()

try:
    level1()
except ValueError as e:
    print(f"在最外层捕获: {e}")

# 部分捕获
def level3():
    raise ValueError("错误")

def level2():
    try:
        level3()
    except ValueError:
        print("Level 2处理了异常")
        raise  # 继续向上传播

def level1():
    try:
        level2()
    except ValueError:
        print("Level 1最终处理")

# 异常上下文
import traceback

def nested_call():
    try:
        level1()
    except ValueError:
        traceback.print_exc()  # 打印完整调用栈

# 获取异常信息
import sys

try:
    1 / 0
except:
    exc_type, exc_value, exc_traceback = sys.exc_info()
    print(f"类型: {exc_type}")
    print(f"值: {exc_value}")
    print(f"追踪: {exc_traceback}")
```

---

## 第156题：上下文管理器

**问题**：使用with语句进行资源管理

**答案**：
```python
# 基本with语句
with open('file.txt', 'r') as f:
    content = f.read()
# 文件自动关闭

# 多个上下文管理器
with open('input.txt', 'r') as infile, \
     open('output.txt', 'w') as outfile:
    content = infile.read()
    outfile.write(content)

# 自定义上下文管理器
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        # 返回True表示抑制异常
        return False

with FileManager('test.txt', 'w') as f:
    f.write('Hello, World!')

# 使用contextlib
from contextlib import contextmanager

@contextmanager
def managed_file(filename, mode):
    try:
        f = open(filename, mode)
        yield f
    finally:
        f.close()

with managed_file('test.txt', 'r') as f:
    print(f.read())

# 异常抑制
from contextlib import suppress

with suppress(FileNotFoundError):
    open('nonexistent.txt', 'r')
# 不会抛出异常

# 临时修改
@contextmanager
def temporary_attr(obj, attr, value):
    """临时修改对象属性"""
    old_value = getattr(obj, attr, None)
    setattr(obj, attr, value)
    try:
        yield obj
    finally:
        if old_value is None:
            delattr(obj, attr)
        else:
            setattr(obj, attr, old_value)
```

---

## 第157题：断言

**问题**：使用assert进行调试

**答案**：
```python
# 基本断言
x = 10
assert x > 0, "x必须为正数"

# 函数前置条件
def withdraw(balance, amount):
    assert amount > 0, "金额必须为正"
    assert amount <= balance, "余额不足"
    return balance - amount

# 不变量检查
class BankAccount:
    def __init__(self, balance):
        self._balance = balance
        self._check_invariant()

    def _check_invariant(self):
        assert self._balance >= 0, "余额不能为负"

    def deposit(self, amount):
        assert amount > 0, "存款金额必须为正"
        self._balance += amount
        self._check_invariant()

    def withdraw(self, amount):
        assert amount > 0, "取款金额必须为正"
        self._balance -= amount
        self._check_invariant()

# 类型检查
def greet(name):
    assert isinstance(name, str), "名字必须是字符串"
    return f"Hello, {name}!"

# 注意事项
# 1. assert可以通过python -O禁用
# 2. 不要用于数据验证，应该用if-raise
# 3. 适合调试和开发阶段使用

# 正确做法（生产环境）
def process_payment(amount):
    if amount <= 0:
        raise ValueError("金额必须为正")
    # 处理支付

# 错误做法
def process_payment(amount):
    assert amount > 0  # 可能被禁用
    # 处理支付
```

---

## 第158题：常见异常类型

**问题**：Python内置的常见异常

**答案**：
```python
# ValueError - 值错误
try:
    int("abc")
except ValueError:
    print("无法转换为整数")

# TypeError - 类型错误
try:
    "string" + 123
except TypeError:
    print("类型不匹配")

# KeyError - 键错误
try:
    d = {'a': 1}
    print(d['b'])
except KeyError:
    print("键不存在")

# IndexError - 索引错误
try:
    lst = [1, 2, 3]
    print(lst[10])
except IndexError:
    print("索引超出范围")

# AttributeError - 属性错误
try:
    "string".nonexistent_method()
except AttributeError:
    print("属性不存在")

# FileNotFoundError - 文件不存在
try:
    open('nonexistent.txt')
except FileNotFoundError:
    print("文件不存在")

# ZeroDivisionError - 除零错误
try:
    10 / 0
except ZeroDivisionError:
    print("不能除以零")

# ImportError - 导入错误
try:
    import nonexistent_module
except ImportError:
    print("模块不存在")

# RuntimeError - 运行时错误
try:
    raise RuntimeError("运行时错误")
except RuntimeError as e:
    print(e)

# StopIteration - 迭代结束
iterator = iter([1, 2, 3])
try:
    while True:
        print(next(iterator))
except StopIteration:
    print("迭代结束")

# 异常层次结构
BaseException
├── SystemExit
├── KeyboardInterrupt
├── GeneratorExit
└── Exception
    ├── StopIteration
    ├── ArithmeticError
    │   ├── ZeroDivisionError
    │   └── OverflowError
    ├── LookupError
    │   ├── KeyError
    │   └── IndexError
    ├── ValueError
    ├── TypeError
    └── ...
```

---

## 第159题：异常链和上下文

**问题**：使用raise from和异常链

**答案**：
```python
# raise from - 显式异常链
def parse_config():
    try:
        with open('config.json') as f:
            return json.loads(f.read())
    except FileNotFoundError as e:
        raise ConfigError("配置文件不存在") from e
    except json.JSONDecodeError as e:
        raise ConfigError("配置文件格式错误") from e

try:
    parse_config()
except ConfigError as e:
    print(f"错误: {e}")
    print(f"原因: {e.__cause__}")

# 隐式异常链
try:
    try:
        1 / 0
    except ZeroDivisionError:
        raise ValueError("转换错误")
except ValueError as e:
    print(f"异常: {e}")
    print(f"上下文: {e.__context__}")

# 抑制异常上下文
try:
    1 / 0
except ZeroDivisionError:
    raise ValueError("错误") from None  # 抑制原异常

# 完整示例
class DataProcessor:
    def process(self, data):
        try:
            self._validate(data)
            self._transform(data)
            self._save(data)
        except ValidationError as e:
            raise ProcessingError("验证失败") from e
        except TransformError as e:
            raise ProcessingError("转换失败") from e
        except SaveError as e:
            raise ProcessingError("保存失败") from e

# 异常追踪
import traceback

try:
    process_data()
except Exception:
    # 打印完整异常链
    traceback.print_exc()

    # 格式化异常信息
    exc_info = traceback.format_exc()
    print(exc_info)
```

---

## 第160题：异常处理最佳实践

**问题**：异常处理的最佳实践

**答案**：
```python
# 1. 具体异常优于通用异常
# 好的做法
try:
    value = int(user_input)
except ValueError:
    print("输入必须是数字")

# 不好的做法
try:
    value = int(user_input)
except Exception:
    print("出错了")

# 2. 不要捕获太广泛的异常
# 好的做法
try:
    process_data()
except (ValueError, TypeError) as e:
    handle_error(e)

# 不好的做法
try:
    process_data()
except:  # 会捕获所有异常，包括KeyboardInterrupt
    pass

# 3. 使用异常而不是返回错误码
# 好的做法
def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("除数不能为零")
    return a / b

# 不好的做法
def divide(a, b):
    if b == 0:
        return None  # 错误码
    return a / b

# 4. 清理资源
# 好的做法
with open('file.txt') as f:
    content = f.read()

# 或者
try:
    f = open('file.txt')
    content = f.read()
finally:
    f.close()

# 5. 不要吞掉异常
# 好的做法
try:
    risky_operation()
except SpecificError as e:
    log_error(e)
    raise

# 不好的做法
try:
    risky_operation()
except:
    pass  # 静默失败

# 6. EAFP vs LBYL
# EAFP (Easier to Ask for Forgiveness than Permission)
try:
    value = d['key']
except KeyError:
    value = None

# LBYL (Look Before You Leap)
if 'key' in d:
    value = d['key']
else:
    value = None

# 7. 日志记录
import logging

try:
    process_data()
except Exception as e:
    logging.error(f"处理失败: {e}", exc_info=True)
    raise
```

---

## 第161题：多重异常处理

**问题**：处理多种异常情况

**答案**：
```python
# 捕获多个异常
try:
    result = operation()
except (ValueError, TypeError) as e:
    print(f"值或类型错误: {e}")
except (KeyError, IndexError) as e:
    print(f"查找错误: {e}")
except Exception as e:
    print(f"其他错误: {e}")

# 分别处理
def process_file(filename):
    try:
        with open(filename) as f:
            data = json.loads(f.read())
            return process(data)
    except FileNotFoundError:
        print(f"文件 {filename} 不存在")
        return None
    except json.JSONDecodeError:
        print("JSON格式错误")
        return None
    except PermissionError:
        print("没有权限读取文件")
        return None
    except Exception as e:
        print(f"未知错误: {e}")
        return None

# 嵌套异常处理
def nested_operations():
    try:
        try:
            risky_operation1()
        except ValueError:
            print("内层处理ValueError")
            # 可以继续执行

        risky_operation2()
    except Exception as e:
        print(f"外层处理: {e}")

# 异常组（Python 3.11+）
try:
    raise ExceptionGroup("多个错误", [
        ValueError("值错误"),
        TypeError("类型错误")
    ])
except* ValueError as eg:
    print(f"处理ValueError: {eg.exceptions}")
except* TypeError as eg:
    print(f"处理TypeError: {eg.exceptions}")

# 实际应用：重试机制
import time

def retry_operation(func, max_retries=3, delay=1):
    for attempt in range(max_retries):
        try:
            return func()
        except ConnectionError as e:
            if attempt < max_retries - 1:
                print(f"重试 {attempt + 1}/{max_retries}")
                time.sleep(delay)
            else:
                raise
        except Exception as e:
            print(f"不可重试的错误: {e}")
            raise
```

---

## 第162题：异常的性能考虑

**问题**：异常处理的性能影响

**答案**：
```python
import timeit

# 异常处理开销
def with_exception():
    try:
        int("invalid")
    except ValueError:
        pass

def with_check():
    s = "invalid"
    if s.isdigit():
        int(s)

# 测试性能
print(timeit.timeit(with_exception, number=100000))
print(timeit.timeit(with_check, number=100000))
# 异常处理通常更慢

# 合适的场景
# 1. 异常情况真的很少发生
def process_data(data):
    try:
        # 大部分情况下data是有效的
        return complex_operation(data)
    except InvalidDataError:
        # 很少发生
        return default_value

# 2. EAFP模式（Python风格）
try:
    value = cache[key]
except KeyError:
    value = expensive_computation()
    cache[key] = value

# 不合适的场景
# 不要用异常做流程控制
# 不好的做法
def find_item(lst, target):
    try:
        index = 0
        while True:
            if lst[index] == target:
                return index
            index += 1
    except IndexError:
        return -1

# 好的做法
def find_item(lst, target):
    for index, item in enumerate(lst):
        if item == target:
            return index
    return -1

# 缓存异常
class CachedError:
    _error_cache = {}

    @classmethod
    def get_error(cls, message):
        if message not in cls._error_cache:
            cls._error_cache[message] = ValueError(message)
        return cls._error_cache[message]
```

---

## 第163题：警告系统

**问题**：使用warnings模块

**答案**：
```python
import warnings

# 发出警告
warnings.warn("这是一个警告")

# 指定警告类别
warnings.warn("已弃用的功能", DeprecationWarning)
warnings.warn("用户警告", UserWarning)
warnings.warn("未来警告", FutureWarning)

# 自定义警告类别
class CustomWarning(UserWarning):
    pass

warnings.warn("自定义警告", CustomWarning)

# 过滤警告
warnings.filterwarnings('ignore')  # 忽略所有警告
warnings.filterwarnings('error')   # 将警告转换为错误
warnings.filterwarnings('always')  # 总是显示警告
warnings.filterwarnings('default') # 默认行为

# 针对特定警告
warnings.filterwarnings('ignore', category=DeprecationWarning)

# 使用装饰器
def deprecated(func):
    def wrapper(*args, **kwargs):
        warnings.warn(
            f"{func.__name__}已弃用",
            DeprecationWarning,
            stacklevel=2
        )
        return func(*args, **kwargs)
    return wrapper

@deprecated
def old_function():
    return "旧功能"

# 上下文管理器
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    # 在此块中忽略警告
    old_function()

# 记录警告
import logging

logging.captureWarnings(True)
warnings.warn("这个警告会被记录")

# 实际应用
class API:
    def old_method(self):
        warnings.warn(
            "old_method已弃用，请使用new_method",
            DeprecationWarning,
            stacklevel=2
        )
        return self.new_method()

    def new_method(self):
        return "新方法"
```

---

## 第164题：调试和追踪

**问题**：使用traceback和sys模块调试

**答案**：
```python
import traceback
import sys

# 打印异常信息
try:
    1 / 0
except:
    traceback.print_exc()

# 获取异常信息
try:
    1 / 0
except:
    exc_info = sys.exc_info()
    print(f"类型: {exc_info[0]}")
    print(f"值: {exc_info[1]}")
    print(f"追踪: {exc_info[2]}")

# 格式化异常
try:
    raise ValueError("测试错误")
except:
    error_msg = traceback.format_exc()
    print(error_msg)

# 提取堆栈信息
try:
    function_chain()
except:
    tb_lines = traceback.format_tb(sys.exc_info()[2])
    for line in tb_lines:
        print(line)

# 自定义异常处理器
def exception_handler(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return

    print("*** 自定义异常处理器 ***")
    print(f"类型: {exc_type.__name__}")
    print(f"值: {exc_value}")
    traceback.print_tb(exc_traceback)

sys.excepthook = exception_handler

# 获取当前堆栈
def print_stack():
    for line in traceback.format_stack():
        print(line.strip())

# 调试信息
import inspect

def debug_info():
    frame = inspect.currentframe()
    print(f"函数: {frame.f_code.co_name}")
    print(f"行号: {frame.f_lineno}")
    print(f"局部变量: {frame.f_locals}")

# 实际应用：错误报告
class ErrorReporter:
    @staticmethod
    def report(exc_type, exc_value, exc_traceback):
        report = {
            'type': exc_type.__name__,
            'message': str(exc_value),
            'traceback': traceback.format_tb(exc_traceback)
        }
        # 发送到日志系统
        return report
```

---

## 第165题：异常处理综合实践

**问题**：构建健壮的错误处理系统

**答案**：
```python
# 综合示例：文件处理器
import logging
from contextlib import contextmanager
from typing import Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class FileProcessingError(Exception):
    """文件处理异常基类"""
    pass

class FileReadError(FileProcessingError):
    """文件读取异常"""
    pass

class FileWriteError(FileProcessingError):
    """文件写入异常"""
    pass

class FileProcessor:
    def __init__(self, input_file: str, output_file: str):
        self.input_file = input_file
        self.output_file = output_file

    def process(self) -> bool:
        """处理文件"""
        try:
            data = self._read_file()
            processed_data = self._process_data(data)
            self._write_file(processed_data)
            logger.info("文件处理成功")
            return True

        except FileReadError as e:
            logger.error(f"读取文件失败: {e}")
            return False

        except FileWriteError as e:
            logger.error(f"写入文件失败: {e}")
            return False

        except Exception as e:
            logger.exception(f"未预期的错误: {e}")
            return False

    def _read_file(self) -> str:
        """读取文件"""
        try:
            with open(self.input_file, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError as e:
            raise FileReadError(f"文件不存在: {self.input_file}") from e
        except PermissionError as e:
            raise FileReadError(f"没有权限: {self.input_file}") from e
        except UnicodeDecodeError as e:
            raise FileReadError(f"编码错误: {self.input_file}") from e

    def _write_file(self, data: str) -> None:
        """写入文件"""
        try:
            with open(self.output_file, 'w', encoding='utf-8') as f:
                f.write(data)
        except PermissionError as e:
            raise FileWriteError(f"没有写入权限: {self.output_file}") from e
        except IOError as e:
            raise FileWriteError(f"IO错误: {self.output_file}") from e

    def _process_data(self, data: str) -> str:
        """处理数据"""
        # 数据处理逻辑
        return data.upper()

# 使用装饰器处理异常
def handle_errors(default_return=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                logger.error(f"{func.__name__} 失败: {e}")
                return default_return
        return wrapper
    return decorator

@handle_errors(default_return=[])
def get_user_data(user_id):
    # 可能抛出异常的操作
    return database.query(user_id)

# 重试装饰器
import time
from functools import wraps

def retry(max_attempts=3, delay=1, exceptions=(Exception,)):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    if attempt == max_attempts - 1:
                        raise
                    logger.warning(
                        f"尝试 {attempt + 1}/{max_attempts} 失败: {e}"
                    )
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=3, delay=2, exceptions=(ConnectionError,))
def fetch_data(url):
    # 网络请求
    pass
```

---

## 学习笔记

在这里记录你的学习心得和遇到的问题：

```
日期：

重点知识：
- try-except-else-finally结构
- 自定义异常类
- 上下文管理器
- 异常链和追踪

易错点：
- 捕获过于宽泛的异常
- 静默吞掉异常
- 滥用异常做流程控制
- finally中的return会覆盖try中的return

实践心得：
```

---

## 进度跟踪

完成题目：0/15

- [ ] 第151题
- [ ] 第152题
- [ ] 第153题
- [ ] 第154题
- [ ] 第155题
- [ ] 第156题
- [ ] 第157题
- [ ] 第158题
- [ ] 第159题
- [ ] 第160题
- [ ] 第161题
- [ ] 第162题
- [ ] 第163题
- [ ] 第164题
- [ ] 第165题
