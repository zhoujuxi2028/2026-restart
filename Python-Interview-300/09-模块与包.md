# 09 - 模块与包（20题）

## 难度分布
- 简单：10题
- 中等：7题
- 困难：3题

---

## 第181题：模块的导入

**问题**：Python模块导入的各种方式

**答案**：
```python
# 导入整个模块
import math
print(math.pi)
print(math.sqrt(16))

# 导入特定函数/类
from math import pi, sqrt
print(pi)
print(sqrt(16))

# 导入所有（不推荐）
from math import *
print(sin(pi/2))

# 使用别名
import numpy as np
from pandas import DataFrame as DF

# 导入子模块
import os.path
from os import path

# 相对导入（在包内使用）
from . import module
from .. import parent_module
from ..sibling import module

# 条件导入
try:
    import ujson as json
except ImportError:
    import json

# 延迟导入
def process_data():
    import pandas as pd  # 只在需要时导入
    return pd.DataFrame()

# 导入时重命名
from very_long_module_name import function as f

# 多行导入
from module import (
    function1,
    function2,
    function3
)
```

---

## 第182题：模块搜索路径

**问题**：Python如何查找模块

**答案**：
```python
import sys

# 查看模块搜索路径
print(sys.path)

# sys.path包含：
# 1. 当前目录
# 2. PYTHONPATH环境变量
# 3. 标准库目录
# 4. site-packages目录

# 添加搜索路径
sys.path.append('/path/to/modules')
sys.path.insert(0, '/priority/path')

# 临时添加路径
import os
import sys

# 添加父目录到路径
parent_dir = os.path.dirname(os.path.dirname(__file__))
sys.path.insert(0, parent_dir)

# 查看模块位置
import math
print(math.__file__)  # 模块文件路径

# 使用PYTHONPATH
# export PYTHONPATH=/path/to/modules:$PYTHONPATH

# .pth文件
# 在site-packages目录创建.pth文件
# 每行一个路径
```

---

## 第183题：\_\_name\_\_和\_\_main\_\_

**问题**：理解模块的\_\_name\_\_属性

**答案**：
```python
# module.py
def main():
    print("执行主函数")

# 作为模块导入时，__name__是模块名
# 直接运行时，__name__是'__main__'
if __name__ == '__main__':
    main()

# 完整示例
# utils.py
def helper_function():
    return "Helper"

def main():
    print("Utils主函数")
    print(helper_function())

if __name__ == '__main__':
    main()

# app.py
import utils

# 导入时不会执行utils.main()
print(utils.helper_function())

# 测试代码
if __name__ == '__main__':
    # 只在直接运行时执行
    run_tests()

# 命令行工具
if __name__ == '__main__':
    import sys
    if len(sys.argv) > 1:
        command = sys.argv[1]
        if command == 'start':
            start_server()
        elif command == 'stop':
            stop_server()
```

---

## 第184题：创建自定义模块

**问题**：创建和使用自定义模块

**答案**：
```python
# mymodule.py
"""
这是一个自定义模块
提供数学计算功能
"""

__version__ = '1.0.0'
__author__ = 'Your Name'

# 模块级变量
DEFAULT_PRECISION = 2

# 私有变量（约定）
_internal_data = []

def add(a, b):
    """两数相加"""
    return a + b

def subtract(a, b):
    """两数相减"""
    return a - b

class Calculator:
    """计算器类"""
    def __init__(self):
        self.result = 0

    def add(self, value):
        self.result += value
        return self

    def get_result(self):
        return self.result

# 私有函数（约定）
def _helper_function():
    pass

# 模块初始化代码
print(f"Module {__name__} loaded")

# 使用模块
# main.py
import mymodule

print(mymodule.__version__)
print(mymodule.__doc__)

result = mymodule.add(5, 3)
calc = mymodule.Calculator()
```

---

## 第185题：\_\_all\_\_变量

**问题**：控制from module import *的行为

**答案**：
```python
# mymodule.py
"""模块说明"""

__all__ = ['public_function', 'PublicClass']

def public_function():
    """公开函数"""
    pass

def _private_function():
    """私有函数"""
    pass

class PublicClass:
    """公开类"""
    pass

class _PrivateClass:
    """私有类"""
    pass

# 使用
# from mymodule import *
# 只会导入__all__中列出的内容

# 明确导入仍然可以
from mymodule import _private_function

# 完整示例
# math_utils.py
__all__ = ['add', 'subtract', 'multiply']

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    # 不在__all__中，不会被*导入
    return a / b

def _internal_helper():
    # 私有函数
    pass
```

---

## 第186题：包的创建

**问题**：创建和使用Python包

**答案**：
```python
# 包结构
mypackage/
    __init__.py
    module1.py
    module2.py
    subpackage/
        __init__.py
        module3.py

# __init__.py
"""
MyPackage - 一个示例包
"""

__version__ = '1.0.0'
__all__ = ['module1', 'module2']

# 在__init__.py中导入子模块
from . import module1
from . import module2
from .module1 import function1

# 简化导入路径
from .subpackage.module3 import SpecialClass

# module1.py
def function1():
    return "Function 1"

class Class1:
    pass

# 使用包
import mypackage
from mypackage import module1
from mypackage.subpackage import module3

# __init__.py高级用法
# 初始化包
def _init_package():
    # 包级别的初始化
    pass

_init_package()

# 延迟导入
def __getattr__(name):
    if name == 'heavy_module':
        from . import heavy_module
        return heavy_module
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")
```

---

## 第187题：命名空间包

**问题**：PEP 420命名空间包

**答案**：
```python
# 命名空间包（无__init__.py）
namespace_package/
    subpackage1/
        module1.py
    subpackage2/
        module2.py

# 可以分布在不同位置
/path1/namespace_package/
    part1/
        module1.py

/path2/namespace_package/
    part2/
        module2.py

# 都可以作为namespace_package导入

# 检查是否是命名空间包
import namespace_package
print(namespace_package.__path__)  # 包含多个路径

# 扩展第三方包
# 创建插件系统
plugins/
    __init__.py  # 空或简单导入

# 其他开发者可以创建
plugins_extra/
    # 相同命名空间

# 使用
import pkgutil

def load_plugins():
    import plugins
    for loader, name, ispkg in pkgutil.iter_modules(plugins.__path__):
        plugin = loader.find_module(name).load_module(name)
        # 使用插件
```

---

## 第188题：相对导入和绝对导入

**问题**：包内模块的相对导入

**答案**：
```python
# 包结构
myapp/
    __init__.py
    core/
        __init__.py
        engine.py
        utils.py
    api/
        __init__.py
        routes.py
        handlers.py

# 绝对导入（推荐）
# api/routes.py
from myapp.core import engine
from myapp.core.utils import helper

# 相对导入
# api/routes.py
from ..core import engine  # 上一级的core
from ..core.utils import helper
from . import handlers  # 当前目录
from .handlers import process  # 当前目录的handlers

# 不同层级的相对导入
# api/handlers.py
from ..core import engine  # 兄弟包
from . import routes  # 同级
from .. import __version__  # 父包

# 注意事项
# 1. 相对导入只能在包内使用
# 2. 相对导入不能用于脚本（__main__）
# 3. 推荐使用绝对导入，更清晰

# 混合使用
from myapp.core import engine  # 绝对导入
from . import utils  # 相对导入
```

---

## 第189题：模块重载

**问题**：重新加载已导入的模块

**答案**：
```python
import importlib

# 导入模块
import mymodule

# 修改mymodule.py后，重新加载
importlib.reload(mymodule)

# 注意事项
# 1. 已创建的对象不会更新
# 2. 已经导入的引用不会改变

# 示例
from mymodule import function
result1 = function()  # 旧版本

# 修改mymodule.py
importlib.reload(mymodule)

# function引用仍是旧版本
result2 = function()  # 仍然是旧版本

# 需要重新导入
from mymodule import function
result3 = function()  # 新版本

# 开发时自动重载
# IPython/Jupyter
%load_ext autoreload
%autoreload 2

# 手动重载系统
class ModuleReloader:
    def __init__(self):
        self.modules = {}

    def watch(self, module):
        import sys
        self.modules[module.__name__] = module

    def reload_all(self):
        for name, module in self.modules.items():
            importlib.reload(module)
```

---

## 第190题：\_\_import\_\_函数

**问题**：动态导入模块

**答案**：
```python
# 使用__import__（不推荐）
math = __import__('math')
print(math.pi)

# 推荐使用importlib
import importlib

# 动态导入
module_name = 'math'
math = importlib.import_module(module_name)
print(math.pi)

# 导入子模块
submodule = importlib.import_module('package.submodule')

# 相对导入
from_module = importlib.import_module('.sibling', package='mypackage')

# 动态加载插件
def load_plugin(plugin_name):
    try:
        module = importlib.import_module(f'plugins.{plugin_name}')
        return module.Plugin()
    except ImportError:
        print(f"插件 {plugin_name} 不存在")

# 根据配置动态导入
config = {
    'backend': 'sqlite',
    'cache': 'redis'
}

backends = {
    'sqlite': 'backends.sqlite',
    'mysql': 'backends.mysql',
    'postgres': 'backends.postgres'
}

backend_module = importlib.import_module(backends[config['backend']])
db = backend_module.Database()

# 检查模块是否可导入
def can_import(module_name):
    try:
        importlib.import_module(module_name)
        return True
    except ImportError:
        return False

if can_import('numpy'):
    import numpy as np
else:
    print("NumPy未安装")
```

---

## 第191题：包管理工具

**问题**：使用pip管理包

**答案**：
```bash
# 安装包
pip install package_name
pip install package_name==1.0.0  # 指定版本
pip install package_name>=1.0.0  # 最小版本
pip install package_name~=1.4.2  # 兼容版本

# 升级包
pip install --upgrade package_name
pip install -U package_name

# 卸载包
pip uninstall package_name

# 列出已安装的包
pip list
pip list --outdated  # 列出可更新的包

# 显示包信息
pip show package_name

# 搜索包
pip search keyword

# 导出依赖
pip freeze > requirements.txt

# 安装依赖
pip install -r requirements.txt

# 本地安装
pip install -e .  # 开发模式
pip install package.tar.gz
pip install /path/to/package

# 从其他源安装
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple package_name
```

```python
# setup.py
from setuptools import setup, find_packages

setup(
    name='mypackage',
    version='1.0.0',
    description='My Package',
    author='Your Name',
    author_email='your.email@example.com',
    url='https://github.com/yourusername/mypackage',
    packages=find_packages(),
    install_requires=[
        'requests>=2.28.0',
        'numpy>=1.21.0'
    ],
    python_requires='>=3.7',
    classifiers=[
        'Development Status :: 4 - Beta',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
    ],
)
```

---

## 第192题：虚拟环境

**问题**：使用虚拟环境隔离项目依赖

**答案**：
```bash
# 创建虚拟环境
python -m venv myenv
python3 -m venv myenv

# 激活虚拟环境
# Windows
myenv\Scripts\activate

# Linux/Mac
source myenv/bin/activate

# 退出虚拟环境
deactivate

# 使用virtualenv
pip install virtualenv
virtualenv myenv
virtualenv -p python3.9 myenv  # 指定Python版本

# 使用conda
conda create -n myenv python=3.9
conda activate myenv
conda deactivate

# 使用pipenv
pip install pipenv
pipenv install  # 创建环境并安装依赖
pipenv shell  # 激活环境
pipenv install package  # 安装包
pipenv lock  # 锁定依赖版本

# 使用poetry
pip install poetry
poetry new myproject
poetry add package
poetry install
poetry shell
```

```python
# 在代码中检测虚拟环境
import sys

def in_virtualenv():
    return (hasattr(sys, 'real_prefix') or
            (hasattr(sys, 'base_prefix') and
             sys.base_prefix != sys.prefix))

if in_virtualenv():
    print("运行在虚拟环境中")
else:
    print("运行在系统Python中")

# 获取虚拟环境路径
print(sys.prefix)
```

---

## 第193题：模块缓存

**问题**：理解Python的模块缓存机制

**答案**：
```python
import sys

# 查看已导入的模块
print(sys.modules.keys())

# 检查模块是否已导入
if 'math' in sys.modules:
    print("math已导入")

# 获取已导入的模块
math_module = sys.modules['math']

# 清除模块缓存
del sys.modules['mymodule']
import mymodule  # 重新导入

# 模块只会被导入一次
import module1  # 执行module1
import module1  # 不会再次执行

# 避免循环导入
# module_a.py
def function_a():
    from module_b import function_b  # 延迟导入
    return function_b()

# module_b.py
def function_b():
    from module_a import function_a
    return function_a()

# 查看模块导入顺序
import sys

class ImportTracker:
    def __init__(self):
        self.imports = []

    def __enter__(self):
        self.original_import = __builtins__.__import__
        __builtins__.__import__ = self.track_import
        return self

    def __exit__(self, *args):
        __builtins__.__import__ = self.original_import

    def track_import(self, name, *args, **kwargs):
        self.imports.append(name)
        return self.original_import(name, *args, **kwargs)

with ImportTracker() as tracker:
    import numpy
    print(f"导入的模块: {tracker.imports}")
```

---

## 第194题：\_\_pycache\_\_和.pyc文件

**问题**：理解Python字节码缓存

**答案**：
```python
# Python会自动创建.pyc文件
# __pycache__/module.cpython-39.pyc

# .pyc文件包含：
# 1. 魔数（Python版本）
# 2. 时间戳
# 3. 字节码

# 禁用.pyc生成
# python -B script.py
# 或设置环境变量
# export PYTHONDONTWRITEBYTECODE=1

import sys
sys.dont_write_bytecode = True

# 清理.pyc文件
import py_compile
import compileall

# 编译单个文件
py_compile.compile('module.py')

# 编译目录
compileall.compile_dir('mypackage')

# 强制重新编译
compileall.compile_dir('mypackage', force=True)

# 优化级别
compileall.compile_dir('mypackage', optimize=2)

# 检查.pyc文件
import importlib.util

def is_pyc_valid(pyc_file, py_file):
    spec = importlib.util.spec_from_file_location("module", pyc_file)
    # 检查时间戳等
    return spec is not None
```

---

## 第195题：内省模块内容

**问题**：查看模块的内容和结构

**答案**：
```python
import math
import inspect

# 查看模块所有属性
print(dir(math))

# 查看模块文档
print(math.__doc__)
print(help(math))

# 查看模块路径
print(math.__file__)

# 查看模块版本
import numpy
print(numpy.__version__)

# 列出模块中的函数
functions = [name for name in dir(math)
             if callable(getattr(math, name))
             and not name.startswith('_')]
print(functions)

# 列出模块中的类
classes = [name for name in dir(math)
           if inspect.isclass(getattr(math, name))]

# 获取函数签名
sig = inspect.signature(math.pow)
print(sig)

# 获取函数源代码
import mymodule
source = inspect.getsource(mymodule.function)
print(source)

# 查看模块成员
for name, obj in inspect.getmembers(math):
    if callable(obj):
        print(f"{name}: {inspect.signature(obj)}")

# 自动生成文档
def document_module(module):
    print(f"模块: {module.__name__}")
    print(f"文档: {module.__doc__}")
    print("\n函数:")

    for name, obj in inspect.getmembers(module):
        if inspect.isfunction(obj):
            print(f"  {name}{inspect.signature(obj)}")
            print(f"    {obj.__doc__}")

# 查找模块位置
import importlib.util

spec = importlib.util.find_spec('numpy')
print(f"NumPy位置: {spec.origin}")
```

---

## 第196题：包的元数据

**问题**：访问包的元数据信息

**答案**：
```python
# 使用importlib.metadata（Python 3.8+）
from importlib import metadata

# 获取包版本
version = metadata.version('numpy')
print(f"NumPy版本: {version}")

# 获取包元数据
meta = metadata.metadata('requests')
print(f"名称: {meta['Name']}")
print(f"版本: {meta['Version']}")
print(f"作者: {meta['Author']}")
print(f"许可: {meta['License']}")

# 列出包文件
files = metadata.files('requests')
for file in files:
    print(file)

# 获取包依赖
requires = metadata.requires('requests')
print(requires)

# 列出所有已安装的包
dists = metadata.distributions()
for dist in dists:
    print(f"{dist.name} {dist.version}")

# 包入口点
entry_points = metadata.entry_points()
for ep in entry_points.select(group='console_scripts'):
    print(f"{ep.name} = {ep.value}")

# 旧方式（兼容性）
try:
    import pkg_resources
    version = pkg_resources.get_distribution('numpy').version
except:
    pass

# 自定义包元数据
# setup.py
setup(
    name='mypackage',
    version='1.0.0',
    metadata_version='2.1',
    ...
)
```

---

## 第197题：包的版本管理

**问题**：管理包的版本信息

**答案**：
```python
# 版本号格式（PEP 440）
# MAJOR.MINOR.PATCH
# 1.2.3
# 1.2.3a1  # alpha
# 1.2.3b1  # beta
# 1.2.3rc1  # release candidate
# 1.2.3.post1  # post release
# 1.2.3.dev1  # development

# 在包中定义版本
# mypackage/__init__.py
__version__ = '1.0.0'

# 从文件读取版本
# version.py
VERSION = (1, 0, 0)
__version__ = '.'.join(map(str, VERSION))

# 动态版本（从git）
import subprocess

def get_version():
    try:
        return subprocess.check_output(
            ['git', 'describe', '--tags'],
            stderr=subprocess.DEVNULL
        ).decode().strip()
    except:
        return 'unknown'

# 版本比较
from packaging import version

v1 = version.parse('1.2.3')
v2 = version.parse('1.2.4')

print(v1 < v2)  # True
print(v1 == version.parse('1.2.3'))  # True

# 版本范围
from packaging.specifiers import SpecifierSet

spec = SpecifierSet('>=1.0.0,<2.0.0')
print(version.parse('1.5.0') in spec)  # True
print(version.parse('2.0.0') in spec)  # False

# setup.py中的版本
setup(
    name='mypackage',
    version='1.0.0',
    # 或者
    version=__import__('mypackage').__version__,
)

# 版本号自动递增
# 使用bumpversion工具
# pip install bump2version
# bump2version patch  # 1.0.0 -> 1.0.1
# bump2version minor  # 1.0.0 -> 1.1.0
# bump2version major  # 1.0.0 -> 2.0.0
```

---

## 第198题：导入钩子

**问题**：自定义模块导入行为

**答案**：
```python
import sys
import importlib.abc
import importlib.machinery

# 自定义查找器
class CustomFinder(importlib.abc.MetaPathFinder):
    def find_spec(self, fullname, path, target=None):
        if fullname.startswith('custom_'):
            # 自定义模块加载逻辑
            return importlib.machinery.ModuleSpec(
                fullname,
                CustomLoader()
            )
        return None

# 自定义加载器
class CustomLoader(importlib.abc.Loader):
    def create_module(self, spec):
        return None  # 使用默认模块创建

    def exec_module(self, module):
        # 自定义模块初始化
        module.custom_attribute = "Custom Value"

# 注册查找器
sys.meta_path.insert(0, CustomFinder())

# 现在可以导入自定义模块
import custom_module
print(custom_module.custom_attribute)

# 实际应用：加密的Python模块
class EncryptedModuleFinder(importlib.abc.MetaPathFinder):
    def find_spec(self, fullname, path, target=None):
        # 查找加密的.pye文件
        if encrypted_file_exists(fullname):
            return importlib.machinery.ModuleSpec(
                fullname,
                EncryptedModuleLoader(fullname)
            )
        return None

# 延迟导入
class LazyLoader(importlib.abc.Loader):
    def __init__(self, loader):
        self.loader = loader

    def create_module(self, spec):
        return self.loader.create_module(spec)

    def exec_module(self, module):
        # 延迟执行
        module.__getattr__ = lambda name: self._load_attribute(name)

# 导入时日志记录
class LoggingFinder(importlib.abc.MetaPathFinder):
    def find_spec(self, fullname, path, target=None):
        print(f"尝试导入: {fullname}")
        return None  # 让其他查找器处理
```

---

## 第199题：包的发布

**问题**：发布Python包到PyPI

**答案**：
```python
# 1. 项目结构
mypackage/
    mypackage/
        __init__.py
        module.py
    tests/
        test_module.py
    setup.py
    README.md
    LICENSE
    MANIFEST.in

# 2. setup.py
from setuptools import setup, find_packages

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

setup(
    name="mypackage",
    version="1.0.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="A short description",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/mypackage",
    packages=find_packages(),
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.7',
    install_requires=[
        'requests>=2.28.0',
    ],
    entry_points={
        'console_scripts': [
            'mycommand=mypackage.cli:main',
        ],
    },
)

# 3. MANIFEST.in
include README.md
include LICENSE
recursive-include tests *.py

# 4. pyproject.toml（推荐）
[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "mypackage"
version = "1.0.0"
description = "A short description"
readme = "README.md"
requires-python = ">=3.7"
license = {text = "MIT"}
authors = [
    {name = "Your Name", email = "your.email@example.com"}
]
dependencies = [
    "requests>=2.28.0"
]

# 5. 构建包
# pip install build
# python -m build

# 6. 上传到PyPI
# pip install twine
# twine upload dist/*

# 7. 测试PyPI
# twine upload --repository testpypi dist/*
```

```bash
# 完整发布流程
# 1. 创建账号
# https://pypi.org/account/register/
# https://test.pypi.org/account/register/

# 2. 创建API token

# 3. 配置~/.pypirc
[distutils]
index-servers =
    pypi
    testpypi

[pypi]
username = __token__
password = pypi-AgE...

[testpypi]
username = __token__
password = pypi-AgE...

# 4. 构建和上传
python -m build
twine check dist/*
twine upload dist/*

# 5. 安装测试
pip install mypackage
```

---

## 第200题：模块和包的最佳实践

**问题**：编写可维护的模块和包

**答案**：
```python
# 1. 清晰的结构
myproject/
    myproject/
        __init__.py
        core/
            __init__.py
            engine.py
        utils/
            __init__.py
            helpers.py
        tests/
            __init__.py
            test_core.py
    docs/
    examples/
    setup.py
    README.md
    LICENSE

# 2. __init__.py最佳实践
# myproject/__init__.py
"""
MyProject - 项目说明
"""

__version__ = '1.0.0'
__author__ = 'Your Name'
__all__ = ['core', 'utils']

# 导入常用内容
from .core import Engine
from .utils import helper_function

# 延迟导入大模块
def __getattr__(name):
    if name == 'heavy_module':
        from . import heavy_module
        return heavy_module
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")

# 3. 文档字符串
def function(param):
    """
    函数简短描述

    详细说明

    Args:
        param: 参数说明

    Returns:
        返回值说明

    Raises:
        ValueError: 异常说明

    Example:
        >>> function("test")
        "result"
    """
    pass

# 4. 类型提示
from typing import List, Dict, Optional

def process_data(
    data: List[int],
    config: Optional[Dict[str, str]] = None
) -> bool:
    """处理数据"""
    pass

# 5. 配置管理
# config.py
class Config:
    DEBUG = False
    DATABASE_URL = 'sqlite:///app.db'

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

# 6. 依赖注入
class Service:
    def __init__(self, config, logger):
        self.config = config
        self.logger = logger

# 7. 单元测试
# tests/test_module.py
import unittest
from myproject import function

class TestFunction(unittest.TestCase):
    def test_basic(self):
        result = function("input")
        self.assertEqual(result, "expected")

# 8. 日志记录
import logging

logger = logging.getLogger(__name__)

def function():
    logger.info("开始处理")
    try:
        # 处理逻辑
        pass
    except Exception as e:
        logger.error(f"处理失败: {e}")
        raise

# 9. 兼容性
import sys

if sys.version_info >= (3, 8):
    from typing import Literal
else:
    try:
        from typing_extensions import Literal
    except ImportError:
        Literal = None

# 10. README.md
"""
# MyProject

## Installation
```bash
pip install myproject
```

## Quick Start
```python
from myproject import Engine

engine = Engine()
engine.run()
```

## Documentation
See [docs](docs/)

## Contributing
See [CONTRIBUTING.md](CONTRIBUTING.md)

## License
MIT
"""
```

---

## 学习笔记

在这里记录你的学习心得和遇到的问题：

```
日期：

重点知识：
- 模块导入机制
- 包的创建和管理
- 相对导入和绝对导入
- 虚拟环境的使用
- 包的发布流程

易错点：
- 循环导入
- 相对导入的使用场景
- __init__.py的作用
- 包的命名空间

实践心得：
```

---

## 进度跟踪

完成题目：0/20

- [ ] 第181题 - [ ] 第182题 - [ ] 第183题 - [ ] 第184题 - [ ] 第185题
- [ ] 第186题 - [ ] 第187题 - [ ] 第188题 - [ ] 第189题 - [ ] 第190题
- [ ] 第191题 - [ ] 第192题 - [ ] 第193题 - [ ] 第194题 - [ ] 第195题
- [ ] 第196题 - [ ] 第197题 - [ ] 第198题 - [ ] 第199题 - [ ] 第200题
