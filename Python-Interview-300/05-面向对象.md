# 05 - 面向对象（30题）

## 难度分布
- 简单：15题
- 中等：10题
- 困难：5题

---

## 第101题：类的定义与实例化

**问题**：创建类和实例的基本方法

**答案**：
```python
# 基本类定义
class Person:
    pass

# 创建实例
person = Person()
print(type(person))  # <class '__main__.Person'>

# 带属性和方法的类
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, I'm {self.name}"

# 创建实例
alice = Person("Alice", 25)
print(alice.name)     # Alice
print(alice.greet())  # Hello, I'm Alice

# 类属性 vs 实例属性
class Person:
    species = "Homo sapiens"  # 类属性

    def __init__(self, name):
        self.name = name  # 实例属性

p1 = Person("Alice")
p2 = Person("Bob")

print(p1.species)  # Homo sapiens
print(Person.species)  # Homo sapiens

# 修改类属性
Person.species = "Human"
print(p1.species)  # Human
print(p2.species)  # Human

# 修改实例属性不影响其他实例
p1.name = "Alice2"
print(p2.name)  # Bob
```

---

## 第102题：__init__和__new__

**问题**：构造函数和初始化方法的区别

**答案**：
```python
# __init__：初始化方法
class Person:
    def __init__(self, name):
        self.name = name
        print(f"Initializing {name}")

p = Person("Alice")

# __new__：构造方法（创建实例）
class Person:
    def __new__(cls, name):
        print(f"Creating instance")
        instance = super().__new__(cls)
        return instance

    def __init__(self, name):
        print(f"Initializing {name}")
        self.name = name

p = Person("Alice")
# 输出：
# Creating instance
# Initializing Alice

# 单例模式
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True

# 不可变类型
class Point:
    def __new__(cls, x, y):
        instance = super().__new__(cls)
        instance.x = x
        instance.y = y
        return instance

    def __init__(self, x, y):
        pass  # 不能修改已设置的属性

# 工厂模式
class Animal:
    def __new__(cls, animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()

class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"
```

---

## 第103题：实例方法、类方法、静态方法

**问题**：三种方法类型的区别和使用

**答案**：
```python
class MyClass:
    class_var = "class variable"

    def __init__(self, value):
        self.instance_var = value

    # 实例方法（默认）
    def instance_method(self):
        return f"Instance: {self.instance_var}"

    # 类方法
    @classmethod
    def class_method(cls):
        return f"Class: {cls.class_var}"

    # 静态方法
    @staticmethod
    def static_method(x, y):
        return x + y

# 调用方式
obj = MyClass("instance value")

# 实例方法
print(obj.instance_method())  # 需要实例

# 类方法
print(MyClass.class_method())  # 可以通过类调用
print(obj.class_method())      # 也可以通过实例

# 静态方法
print(MyClass.static_method(3, 5))  # 可以通过类调用
print(obj.static_method(3, 5))      # 也可以通过实例

# 实际应用：工厂方法
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    @classmethod
    def from_string(cls, date_string):
        year, month, day = map(int, date_string.split('-'))
        return cls(year, month, day)

    @classmethod
    def today(cls):
        import datetime
        today = datetime.date.today()
        return cls(today.year, today.month, today.day)

    @staticmethod
    def is_valid_date(year, month, day):
        return 1 <= month <= 12 and 1 <= day <= 31

# 使用
d1 = Date(2024, 1, 1)
d2 = Date.from_string("2024-01-01")
d3 = Date.today()
print(Date.is_valid_date(2024, 13, 1))  # False
```

---

## 第104题：继承

**问题**：类的继承和方法重写

**答案**：
```python
# 基本继承
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "Some sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

dog = Dog("Buddy")
print(dog.name)    # Buddy（继承的属性）
print(dog.speak()) # Woof!（重写的方法）

# 调用父类方法
class Dog(Animal):
    def speak(self):
        parent_sound = super().speak()
        return f"{parent_sound} - Woof!"

# 多级继承
class LivingThing:
    def breathe(self):
        return "Breathing"

class Animal(LivingThing):
    def move(self):
        return "Moving"

class Dog(Animal):
    def bark(self):
        return "Woof!"

dog = Dog()
print(dog.breathe())  # Breathing
print(dog.move())     # Moving
print(dog.bark())     # Woof!

# 检查继承关系
print(isinstance(dog, Dog))         # True
print(isinstance(dog, Animal))      # True
print(isinstance(dog, LivingThing)) # True

print(issubclass(Dog, Animal))      # True
print(issubclass(Dog, LivingThing)) # True

# 获取父类
print(Dog.__bases__)  # (<class 'Animal'>,)
print(Dog.mro())      # 方法解析顺序
```

---

## 第105题：多重继承

**问题**：多重继承和MRO

**答案**：
```python
# 基本多重继承
class A:
    def method(self):
        return "A"

class B:
    def method(self):
        return "B"

class C(A, B):
    pass

c = C()
print(c.method())  # A（继承顺序：C -> A -> B）

# MRO（方法解析顺序）
print(C.mro())
# [<class 'C'>, <class 'A'>, <class 'B'>, <class 'object'>]

# 菱形继承问题
class A:
    def __init__(self):
        print("A.__init__")

class B(A):
    def __init__(self):
        print("B.__init__")
        super().__init__()

class C(A):
    def __init__(self):
        print("C.__init__")
        super().__init__()

class D(B, C):
    def __init__(self):
        print("D.__init__")
        super().__init__()

d = D()
# D.__init__
# B.__init__
# C.__init__
# A.__init__

# Mixin模式
class JSONMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class JSONPerson(Person, JSONMixin):
    pass

p = JSONPerson("Alice", 25)
print(p.to_json())  # {"name": "Alice", "age": 25}

# 实际应用：多功能类
class WalkMixin:
    def walk(self):
        return "Walking"

class SwimMixin:
    def swim(self):
        return "Swimming"

class FlyMixin:
    def fly(self):
        return "Flying"

class Duck(WalkMixin, SwimMixin, FlyMixin):
    pass

class Fish(SwimMixin):
    pass

duck = Duck()
print(duck.walk())  # Walking
print(duck.swim())  # Swimming
print(duck.fly())   # Flying
```

---

## 第106题：封装与访问控制

**问题**：Python中的访问控制

**答案**：
```python
class BankAccount:
    def __init__(self, balance):
        self.public = "public"      # 公开属性
        self._protected = "protected"  # 受保护属性（约定）
        self.__private = "private"     # 私有属性（名称改编）

    def get_balance(self):
        return self.__private

account = BankAccount(1000)

# 访问公开属性
print(account.public)  # public

# 访问受保护属性（不推荐，但可以）
print(account._protected)  # protected

# 访问私有属性（会报错）
# print(account.__private)  # AttributeError

# 通过名称改编访问（不推荐）
print(account._BankAccount__private)  # private

# 使用property装饰器
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance

    @property
    def balance(self):
        """获取余额"""
        return self.__balance

    @balance.setter
    def balance(self, value):
        """设置余额"""
        if value < 0:
            raise ValueError("余额不能为负")
        self.__balance = value

    @balance.deleter
    def balance(self):
        """删除余额"""
        print("删除余额")
        del self.__balance

account = BankAccount(1000)
print(account.balance)  # 1000（调用getter）
account.balance = 2000  # 调用setter
# account.balance = -100  # ValueError

# 只读属性
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @property
    def area(self):
        import math
        return math.pi * self._radius ** 2

    @property
    def circumference(self):
        import math
        return 2 * math.pi * self._radius

circle = Circle(5)
print(circle.area)  # 78.54...
# circle.area = 100  # AttributeError（只读）
```

---

## 第107题：特殊方法（魔术方法）

**问题**：常用的特殊方法

**答案**：
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 字符串表示
    def __str__(self):
        """用户友好的字符串"""
        return f"Person({self.name}, {self.age})"

    def __repr__(self):
        """开发者友好的字符串"""
        return f"Person(name='{self.name}', age={self.age})"

    # 比较运算
    def __eq__(self, other):
        return self.name == other.name and self.age == other.age

    def __lt__(self, other):
        return self.age < other.age

    def __le__(self, other):
        return self.age <= other.age

    # 长度
    def __len__(self):
        return len(self.name)

    # 调用
    def __call__(self):
        return f"Calling {self.name}"

# 使用
p1 = Person("Alice", 25)
p2 = Person("Bob", 30)

print(str(p1))   # Person(Alice, 25)
print(repr(p1))  # Person(name='Alice', age=25)

print(p1 == p2)  # False
print(p1 < p2)   # True

print(len(p1))   # 5
print(p1())      # Calling Alice

# 容器类型的特殊方法
class CustomList:
    def __init__(self):
        self.items = []

    def __getitem__(self, index):
        return self.items[index]

    def __setitem__(self, index, value):
        self.items[index] = value

    def __delitem__(self, index):
        del self.items[index]

    def __len__(self):
        return len(self.items)

    def __contains__(self, item):
        return item in self.items

    def append(self, item):
        self.items.append(item)

lst = CustomList()
lst.append(1)
lst.append(2)
lst.append(3)

print(lst[0])     # 1
print(len(lst))   # 3
print(2 in lst)   # True

# 算术运算
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
print(v1 + v2)  # Vector(4, 6)
print(v1 * 3)   # Vector(3, 6)
```

---

## 第108题：属性访问控制

**问题**：__getattr__、__setattr__等方法

**答案**：
```python
class DynamicAttributes:
    def __getattr__(self, name):
        """当访问不存在的属性时调用"""
        return f"{name} not found"

    def __setattr__(self, name, value):
        """设置属性时调用"""
        print(f"Setting {name} = {value}")
        super().__setattr__(name, value)

    def __delattr__(self, name):
        """删除属性时调用"""
        print(f"Deleting {name}")
        super().__delattr__(name)

obj = DynamicAttributes()
print(obj.nonexistent)  # nonexistent not found
obj.x = 10              # Setting x = 10
del obj.x               # Deleting x

# 实际应用：属性验证
class ValidatedAttribute:
    def __init__(self):
        pass

    def __setattr__(self, name, value):
        if name == "age" and value < 0:
            raise ValueError("年龄不能为负")
        if name == "name" and not isinstance(value, str):
            raise TypeError("名字必须是字符串")
        super().__setattr__(name, value)

obj = ValidatedAttribute()
obj.name = "Alice"  # OK
# obj.age = -5      # ValueError
# obj.name = 123    # TypeError

# __getattribute__（更底层）
class TrackedAccess:
    def __init__(self):
        super().__setattr__('access_count', 0)
        super().__setattr__('value', 42)

    def __getattribute__(self, name):
        """所有属性访问都会调用"""
        if name != 'access_count':
            count = super().__getattribute__('access_count')
            super().__setattr__('access_count', count + 1)
        return super().__getattribute__(name)

obj = TrackedAccess()
print(obj.value)  # 42
print(obj.value)  # 42
print(obj.access_count)  # 2

# 代理模式
class Proxy:
    def __init__(self, target):
        self._target = target

    def __getattr__(self, name):
        print(f"Accessing {name}")
        return getattr(self._target, name)

    def __setattr__(self, name, value):
        if name == '_target':
            super().__setattr__(name, value)
        else:
            print(f"Setting {name} = {value}")
            setattr(self._target, name, value)

class RealObject:
    def __init__(self):
        self.value = 42

real = RealObject()
proxy = Proxy(real)
print(proxy.value)  # Accessing value, 42
proxy.value = 100   # Setting value = 100
```

---

## 第109题：描述符

**问题**：描述符协议的使用

**答案**：
```python
# 基本描述符
class Descriptor:
    def __get__(self, obj, objtype=None):
        print("Getting value")
        return self.value

    def __set__(self, obj, value):
        print(f"Setting value to {value}")
        self.value = value

    def __delete__(self, obj):
        print("Deleting value")
        del self.value

class MyClass:
    attr = Descriptor()

obj = MyClass()
obj.attr = 10   # Setting value to 10
print(obj.attr) # Getting value, 10
del obj.attr    # Deleting value

# 实际应用：类型检查
class TypedProperty:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return obj.__dict__.get(self.name)

    def __set__(self, obj, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(
                f"{self.name} must be {self.expected_type.__name__}"
            )
        obj.__dict__[self.name] = value

class Person:
    name = TypedProperty("name", str)
    age = TypedProperty("age", int)

    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("Alice", 25)
# p.age = "25"  # TypeError

# 延迟属性
class LazyProperty:
    def __init__(self, func):
        self.func = func
        self.name = func.__name__

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        value = self.func(obj)
        setattr(obj, self.name, value)
        return value

class DataProcessor:
    def __init__(self, data):
        self.data = data

    @LazyProperty
    def processed_data(self):
        print("Processing data...")
        return [x * 2 for x in self.data]

dp = DataProcessor([1, 2, 3])
print(dp.processed_data)  # Processing data..., [2, 4, 6]
print(dp.processed_data)  # [2, 4, 6]（不再处理）

# 范围检查
class RangeDescriptor:
    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return obj.__dict__.get(self.name)

    def __set__(self, obj, value):
        if not self.min_value <= value <= self.max_value:
            raise ValueError(
                f"{self.name} must be between "
                f"{self.min_value} and {self.max_value}"
            )
        obj.__dict__[self.name] = value

class Student:
    grade = RangeDescriptor(0, 100)

    def __init__(self, grade):
        self.grade = grade

s = Student(85)
# s.grade = 150  # ValueError
```

---

## 第110题：抽象基类

**问题**：使用abc模块定义抽象类

**答案**：
```python
from abc import ABC, abstractmethod

# 定义抽象类
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

    @abstractmethod
    def move(self):
        pass

    def breathe(self):
        """具体方法"""
        return "Breathing"

# 不能实例化抽象类
# animal = Animal()  # TypeError

# 实现抽象类
class Dog(Animal):
    def speak(self):
        return "Woof!"

    def move(self):
        return "Running"

dog = Dog()
print(dog.speak())   # Woof!
print(dog.breathe()) # Breathing

# 抽象属性
class Shape(ABC):
    @property
    @abstractmethod
    def area(self):
        pass

    @property
    @abstractmethod
    def perimeter(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        import math
        return math.pi * self.radius ** 2

    @property
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius

# 检查实现
from abc import ABCMeta

def check_implementation(cls):
    """检查类是否完全实现了抽象方法"""
    abstract_methods = cls.__abstractmethods__
    if abstract_methods:
        print(f"Missing: {abstract_methods}")
    else:
        print("All methods implemented")

# 虚拟子类
class MyList(ABC):
    @abstractmethod
    def append(self, item):
        pass

# 注册虚拟子类
MyList.register(list)
print(issubclass(list, MyList))  # True
print(isinstance([], MyList))    # True

# 实际应用：接口定义
class DataProcessor(ABC):
    @abstractmethod
    def process(self, data):
        """处理数据"""
        pass

    @abstractmethod
    def validate(self, data):
        """验证数据"""
        pass

class CSVProcessor(DataProcessor):
    def process(self, data):
        return data.split(',')

    def validate(self, data):
        return isinstance(data, str) and ',' in data
```

---

## 第111题：元类

**问题**：理解和使用元类

**答案**：
```python
# type是所有类的元类
class MyClass:
    pass

print(type(MyClass))  # <class 'type'>
print(type(int))      # <class 'type'>
print(type(str))      # <class 'type'>

# 使用type动态创建类
def method(self):
    return "method called"

MyClass = type('MyClass', (), {'method': method})
obj = MyClass()
print(obj.method())  # method called

# 自定义元类
class Meta(type):
    def __new__(mcs, name, bases, attrs):
        print(f"Creating class {name}")
        # 修改类属性
        attrs['created_by'] = 'Meta'
        return super().__new__(mcs, name, bases, attrs)

class MyClass(metaclass=Meta):
    pass

print(MyClass.created_by)  # Meta

# 实际应用：单例元类
class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=Singleton):
    def __init__(self):
        print("Initializing database")

db1 = Database()  # Initializing database
db2 = Database()  # 不输出（使用缓存的实例）
print(db1 is db2)  # True

# 属性验证元类
class ValidatedMeta(type):
    def __new__(mcs, name, bases, attrs):
        for key, value in attrs.items():
            if key.startswith('_') or callable(value):
                continue
            # 将属性转换为property
            private_name = f'_{key}'
            attrs[private_name] = value

            def make_property(attr_name):
                def getter(self):
                    return getattr(self, attr_name)
                def setter(self, value):
                    if not isinstance(value, (int, float, str)):
                        raise TypeError(f"{attr_name} must be a basic type")
                    setattr(self, attr_name, value)
                return property(getter, setter)

            attrs[key] = make_property(private_name)

        return super().__new__(mcs, name, bases, attrs)

# 注册元类
class PluginRegistry(type):
    plugins = []

    def __new__(mcs, name, bases, attrs):
        cls = super().__new__(mcs, name, bases, attrs)
        if name != 'Plugin':
            mcs.plugins.append(cls)
        return cls

class Plugin(metaclass=PluginRegistry):
    pass

class PluginA(Plugin):
    pass

class PluginB(Plugin):
    pass

print(PluginRegistry.plugins)  # [PluginA, PluginB]
```

---

## 第112题：数据类

**问题**：使用dataclass简化类定义

**答案**：
```python
from dataclasses import dataclass, field

# 基本数据类
@dataclass
class Person:
    name: str
    age: int
    city: str = "Unknown"  # 默认值

p = Person("Alice", 25)
print(p)  # Person(name='Alice', age=25, city='Unknown')

# 自动生成的方法
p1 = Person("Alice", 25)
p2 = Person("Alice", 25)
print(p1 == p2)  # True（自动生成__eq__）

# 不可变数据类
@dataclass(frozen=True)
class Point:
    x: int
    y: int

p = Point(1, 2)
# p.x = 3  # FrozenInstanceError

# 字段配置
@dataclass
class Product:
    name: str
    price: float
    quantity: int = 0
    tags: list = field(default_factory=list)  # 可变默认值
    _id: int = field(init=False, repr=False)  # 不在__init__中

    def __post_init__(self):
        """初始化后调用"""
        import random
        self._id = random.randint(1000, 9999)

# 排序
@dataclass(order=True)
class Student:
    sort_index: int = field(init=False, repr=False)
    name: str
    grade: int

    def __post_init__(self):
        self.sort_index = self.grade

students = [
    Student("Alice", 85),
    Student("Bob", 92),
    Student("Charlie", 78)
]
print(sorted(students))  # 按grade排序

# 转换为字典
from dataclasses import asdict, astuple

@dataclass
class Person:
    name: str
    age: int

p = Person("Alice", 25)
print(asdict(p))   # {'name': 'Alice', 'age': 25}
print(astuple(p))  # ('Alice', 25)

# 继承
@dataclass
class Employee(Person):
    salary: float
    department: str

e = Employee("Bob", 30, 50000, "IT")
```

---

## 第113题：属性装饰器

**问题**：使用property装饰器

**答案**：
```python
# 基本property
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """获取半径"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """设置半径"""
        if value < 0:
            raise ValueError("半径不能为负")
        self._radius = value

    @property
    def area(self):
        """计算面积（只读）"""
        import math
        return math.pi * self._radius ** 2

circle = Circle(5)
print(circle.radius)  # 5
circle.radius = 10    # 设置
print(circle.area)    # 314.159...
# circle.area = 100   # AttributeError（只读）

# 删除器
class Person:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        return self._name

    @name.deleter
    def name(self):
        print(f"Deleting name: {self._name}")
        del self._name

p = Person("Alice")
del p.name  # Deleting name: Alice

# 缓存属性
class DataProcessor:
    def __init__(self, data):
        self.data = data
        self._processed = None

    @property
    def processed(self):
        if self._processed is None:
            print("Processing data...")
            self._processed = [x * 2 for x in self.data]
        return self._processed

dp = DataProcessor([1, 2, 3])
print(dp.processed)  # Processing data..., [2, 4, 6]
print(dp.processed)  # [2, 4, 6]（使用缓存）

# 依赖属性
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        self._width = value
        self._clear_cache()

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        self._height = value
        self._clear_cache()

    @property
    def area(self):
        if not hasattr(self, '_area'):
            self._area = self._width * self._height
        return self._area

    def _clear_cache(self):
        if hasattr(self, '_area'):
            del self._area

# 验证属性
class User:
    def __init__(self, email):
        self.email = email

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, value):
        if '@' not in value:
            raise ValueError("Invalid email")
        self._email = value

user = User("alice@example.com")
# user.email = "invalid"  # ValueError
```

---

## 第114题：运算符重载

**问题**：重载算术和比较运算符

**答案**：
```python
# 算术运算符
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    def __truediv__(self, scalar):
        return Vector(self.x / scalar, self.y / scalar)

    def __neg__(self):
        return Vector(-self.x, -self.y)

    def __abs__(self):
        import math
        return math.sqrt(self.x**2 + self.y**2)

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)  # Vector(4, 6)
print(v1 - v2)  # Vector(-2, -2)
print(v1 * 3)   # Vector(3, 6)
print(-v1)      # Vector(-1, -2)
print(abs(v1))  # 2.23...

# 增强赋值
class Counter:
    def __init__(self, value=0):
        self.value = value

    def __iadd__(self, other):
        self.value += other
        return self

    def __isub__(self, other):
        self.value -= other
        return self

counter = Counter(10)
counter += 5
print(counter.value)  # 15

# 比较运算符
from functools import total_ordering

@total_ordering
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.age == other.age

    def __lt__(self, other):
        return self.age < other.age

    # 其他比较运算符由@total_ordering自动生成

p1 = Person("Alice", 25)
p2 = Person("Bob", 30)

print(p1 < p2)   # True
print(p1 > p2)   # False
print(p1 <= p2)  # True
print(p1 >= p2)  # False

# 位运算符
class Permissions:
    def __init__(self, value):
        self.value = value

    def __and__(self, other):
        return Permissions(self.value & other.value)

    def __or__(self, other):
        return Permissions(self.value | other.value)

    def __xor__(self, other):
        return Permissions(self.value ^ other.value)

    def __invert__(self):
        return Permissions(~self.value)

READ = Permissions(4)   # 100
WRITE = Permissions(2)  # 010
EXEC = Permissions(1)   # 001

perms = READ | WRITE
print(perms.value)  # 6 (110)
```

---

## 第115题：上下文管理器

**问题**：实现__enter__和__exit__

**答案**：
```python
# 基本上下文管理器
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        # 返回True抑制异常，返回False传播异常
        return False

with FileManager('test.txt', 'w') as f:
    f.write('Hello, World!')

# 使用contextlib
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    f = open(filename, mode)
    try:
        yield f
    finally:
        f.close()

with file_manager('test.txt', 'r') as f:
    print(f.read())

# 数据库连接管理
class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.conn = None

    def __enter__(self):
        print(f"Connecting to {self.db_name}")
        # self.conn = connect(self.db_name)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Closing connection to {self.db_name}")
        if self.conn:
            if exc_type is None:
                # self.conn.commit()
                pass
            else:
                # self.conn.rollback()
                pass
            # self.conn.close()
        return False

# 计时器
import time

class Timer:
    def __enter__(self):
        self.start = time.time()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end = time.time()
        self.elapsed = self.end - self.start
        print(f"Elapsed time: {self.elapsed:.4f}s")
        return False

with Timer():
    time.sleep(1)
    print("Doing something")

# 异常处理
class ErrorHandler:
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            print(f"Caught {exc_type.__name__}: {exc_val}")
            return True  # 抑制异常
        return False

with ErrorHandler():
    raise ValueError("Test error")
    print("This won't print")

print("Program continues")

# 临时修改
@contextmanager
def temp_attr(obj, **attrs):
    """临时修改对象属性"""
    old_attrs = {}
    for key, value in attrs.items():
        old_attrs[key] = getattr(obj, key, None)
        setattr(obj, key, value)
    try:
        yield obj
    finally:
        for key, value in old_attrs.items():
            setattr(obj, key, value)

class Config:
    debug = False

config = Config()
print(config.debug)  # False

with temp_attr(config, debug=True):
    print(config.debug)  # True

print(config.debug)  # False
```

---

## 第116题：迭代器协议

**问题**：实现可迭代对象

**答案**：
```python
# 基本迭代器
class Counter:
    def __init__(self, max_value):
        self.max_value = max_value
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.max_value:
            raise StopIteration
        self.current += 1
        return self.current

counter = Counter(5)
for i in counter:
    print(i)  # 1, 2, 3, 4, 5

# 可迭代对象（返回新迭代器）
class Range:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        return RangeIterator(self.start, self.end)

class RangeIterator:
    def __init__(self, start, end):
        self.current = start
        self.end = end

    def __iter__(self):
        return self

    def __next__(self):
        if self.current >= self.end:
            raise StopIteration
        value = self.current
        self.current += 1
        return value

r = Range(0, 5)
for i in r:
    print(i)

# 可以多次迭代
for i in r:
    print(i)

# 斐波那契迭代器
class Fibonacci:
    def __init__(self, max_count):
        self.max_count = max_count
        self.count = 0
        self.a, self.b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.count >= self.max_count:
            raise StopIteration
        self.count += 1
        value = self.a
        self.a, self.b = self.b, self.a + self.b
        return value

fib = Fibonacci(10)
for num in fib:
    print(num, end=' ')
# 0 1 1 2 3 5 8 13 21 34

# 反向迭代
class Countdown:
    def __init__(self, start):
        self.start = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        value = self.start
        self.start -= 1
        return value

    def __reversed__(self):
        """支持reversed()"""
        return Range(1, self.start + 1)

# 自定义序列
class MySequence:
    def __init__(self, items):
        self.items = items

    def __len__(self):
        return len(self.items)

    def __getitem__(self, index):
        return self.items[index]

    # 有了__getitem__和__len__，自动支持迭代
    # Python会自动创建迭代器

seq = MySequence([1, 2, 3, 4, 5])
for item in seq:
    print(item)

# 也支持reversed
for item in reversed(seq):
    print(item)
```

---

## 第117题：类装饰器

**问题**：使用装饰器修改类

**答案**：
```python
# 基本类装饰器
def add_method(cls):
    """添加方法到类"""
    def new_method(self):
        return "New method"
    cls.new_method = new_method
    return cls

@add_method
class MyClass:
    pass

obj = MyClass()
print(obj.new_method())  # New method

# 添加属性
def add_repr(cls):
    """添加__repr__方法"""
    def __repr__(self):
        attrs = ', '.join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{cls.__name__}({attrs})"
    cls.__repr__ = __repr__
    return cls

@add_repr
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("Alice", 25)
print(p)  # Person(name='Alice', age=25)

# 单例装饰器
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Database:
    def __init__(self):
        print("Initializing database")

db1 = Database()  # Initializing database
db2 = Database()  # 不输出
print(db1 is db2)  # True

# 计数装饰器
def count_instances(cls):
    cls._instance_count = 0
    original_init = cls.__init__

    def new_init(self, *args, **kwargs):
        cls._instance_count += 1
        original_init(self, *args, **kwargs)

    cls.__init__ = new_init

    @classmethod
    def get_instance_count(cls):
        return cls._instance_count

    cls.get_instance_count = get_instance_count
    return cls

@count_instances
class Person:
    def __init__(self, name):
        self.name = name

p1 = Person("Alice")
p2 = Person("Bob")
print(Person.get_instance_count())  # 2

# 验证装饰器
def validate_attributes(cls):
    """验证类属性"""
    original_setattr = cls.__setattr__

    def new_setattr(self, name, value):
        if hasattr(cls, f'_validate_{name}'):
            validator = getattr(cls, f'_validate_{name}')
            if not validator(value):
                raise ValueError(f"Invalid value for {name}")
        original_setattr(self, name, value)

    cls.__setattr__ = new_setattr
    return cls

@validate_attributes
class Person:
    def __init__(self, age):
        self.age = age

    @staticmethod
    def _validate_age(value):
        return 0 <= value <= 120

p = Person(25)
# p.age = 150  # ValueError
```

---

## 第118题：slots优化

**问题**：使用__slots__优化内存

**答案**：
```python
# 不使用__slots__
class PersonWithoutSlots:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# 使用__slots__
class PersonWithSlots:
    __slots__ = ['name', 'age']

    def __init__(self, name, age):
        self.name = name
        self.age = age

# 内存比较
import sys

p1 = PersonWithoutSlots("Alice", 25)
p2 = PersonWithSlots("Alice", 25)

print(sys.getsizeof(p1.__dict__))  # 更大
print(sys.getsizeof(p2))           # 更小

# __slots__限制属性
p2 = PersonWithSlots("Alice", 25)
# p2.city = "NYC"  # AttributeError

# 没有__dict__
print(hasattr(p1, '__dict__'))  # True
print(hasattr(p2, '__dict__'))  # False

# 继承中的__slots__
class Person:
    __slots__ = ['name']

class Employee(Person):
    __slots__ = ['salary']  # 总共有name和salary

e = Employee()
e.name = "Alice"
e.salary = 50000
# e.age = 25  # AttributeError

# 性能测试
import timeit

def test_without_slots():
    p = PersonWithoutSlots("Alice", 25)
    p.name = "Bob"
    return p.name

def test_with_slots():
    p = PersonWithSlots("Alice", 25)
    p.name = "Bob"
    return p.name

print(timeit.timeit(test_without_slots, number=1000000))
print(timeit.timeit(test_with_slots, number=1000000))  # 通常更快

# 何时使用__slots__：
# 1. 创建大量实例
# 2. 实例属性固定
# 3. 需要优化内存
# 4. 需要轻微的性能提升

# 注意事项：
# 1. 失去__dict__，无法动态添加属性
# 2. 继承复杂
# 3. 不能使用weakref（除非包含__weakref__）
```

---

## 第119题：混入类（Mixin）

**问题**：使用Mixin组合功能

**答案**：
```python
# 基本Mixin
class JSONMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

    @classmethod
    def from_json(cls, json_str):
        import json
        data = json.loads(json_str)
        return cls(**data)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class JSONPerson(JSONMixin, Person):
    pass

p = JSONPerson("Alice", 25)
json_str = p.to_json()
print(json_str)  # {"name": "Alice", "age": 25}

p2 = JSONPerson.from_json(json_str)
print(p2.name, p2.age)

# 多个Mixin
class ReprMixin:
    def __repr__(self):
        attrs = ', '.join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{self.__class__.__name__}({attrs})"

class CompareMixin:
    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def __hash__(self):
        return hash(tuple(sorted(self.__dict__.items())))

class Person(ReprMixin, CompareMixin):
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Alice", 25)
p2 = Person("Alice", 25)

print(p1)           # Person(name='Alice', age=25)
print(p1 == p2)     # True
print(hash(p1) == hash(p2))  # True

# 日志Mixin
class LoggerMixin:
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")

class Database(LoggerMixin):
    def connect(self):
        self.log("Connecting to database")

    def query(self, sql):
        self.log(f"Executing: {sql}")

db = Database()
db.connect()
db.query("SELECT * FROM users")

# 验证Mixin
class ValidationMixin:
    def validate(self):
        """验证所有以_validate开头的方法"""
        for name in dir(self):
            if name.startswith('_validate_'):
                validator = getattr(self, name)
                if not validator():
                    raise ValueError(f"Validation failed: {name}")
        return True

class User(ValidationMixin):
    def __init__(self, email, age):
        self.email = email
        self.age = age

    def _validate_email(self):
        return '@' in self.email

    def _validate_age(self):
        return 0 <= self.age <= 120

user = User("alice@example.com", 25)
user.validate()  # OK
```

---

## 第120题：设计模式 - 单例模式

**问题**：实现单例模式的多种方式

**答案**：
```python
# 方法1: 使用__new__
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True

# 方法2: 使用装饰器
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Database:
    def __init__(self, name):
        self.name = name

# 方法3: 使用元类
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self, name):
        self.name = name

# 方法4: 使用模块
# singleton.py
class Database:
    def __init__(self):
        print("Initializing database")

database = Database()  # 模块级单例

# 使用
# from singleton import database

# 线程安全的单例
import threading

class ThreadSafeSingleton:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
```

---

## 第121题：设计模式 - 工厂模式

**问题**：实现工厂模式

**答案**：
```python
# 简单工厂
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

class AnimalFactory:
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError(f"Unknown animal type: {animal_type}")

animal = AnimalFactory.create_animal("dog")
print(animal.speak())  # Woof!

# 工厂方法模式
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class AnimalFactory(ABC):
    @abstractmethod
    def create_animal(self):
        pass

    def get_animal(self):
        animal = self.create_animal()
        return animal

class DogFactory(AnimalFactory):
    def create_animal(self):
        return Dog()

class CatFactory(AnimalFactory):
    def create_animal(self):
        return Cat()

factory = DogFactory()
animal = factory.get_animal()
print(animal.speak())

# 抽象工厂模式
class Button(ABC):
    @abstractmethod
    def render(self):
        pass

class WindowsButton(Button):
    def render(self):
        return "Windows Button"

class MacButton(Button):
    def render(self):
        return "Mac Button"

class Checkbox(ABC):
    @abstractmethod
    def render(self):
        pass

class WindowsCheckbox(Checkbox):
    def render(self):
        return "Windows Checkbox"

class MacCheckbox(Checkbox):
    def render(self):
        return "Mac Checkbox"

class GUIFactory(ABC):
    @abstractmethod
    def create_button(self):
        pass

    @abstractmethod
    def create_checkbox(self):
        pass

class WindowsFactory(GUIFactory):
    def create_button(self):
        return WindowsButton()

    def create_checkbox(self):
        return WindowsCheckbox()

class MacFactory(GUIFactory):
    def create_button(self):
        return MacButton()

    def create_checkbox(self):
        return MacCheckbox()

factory = WindowsFactory()
button = factory.create_button()
checkbox = factory.create_checkbox()
```

---

## 第122题：设计模式 - 观察者模式

**问题**：实现观察者模式

**答案**：
```python
from abc import ABC, abstractmethod

# 观察者接口
class Observer(ABC):
    @abstractmethod
    def update(self, subject):
        pass

# 主题
class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update(self)

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        self._state = value
        self.notify()

# 具体观察者
class ConcreteObserver(Observer):
    def __init__(self, name):
        self.name = name

    def update(self, subject):
        print(f"{self.name} received update: {subject.state}")

# 使用
subject = Subject()

observer1 = ConcreteObserver("Observer1")
observer2 = ConcreteObserver("Observer2")

subject.attach(observer1)
subject.attach(observer2)

subject.state = "New State"
# Observer1 received update: New State
# Observer2 received update: New State

# 实际应用：事件系统
class EventManager:
    def __init__(self):
        self._events = {}

    def subscribe(self, event_name, callback):
        if event_name not in self._events:
            self._events[event_name] = []
        self._events[event_name].append(callback)

    def unsubscribe(self, event_name, callback):
        if event_name in self._events:
            self._events[event_name].remove(callback)

    def emit(self, event_name, *args, **kwargs):
        if event_name in self._events:
            for callback in self._events[event_name]:
                callback(*args, **kwargs)

# 使用
events = EventManager()

def on_user_login(username):
    print(f"User {username} logged in")

def on_user_logout(username):
    print(f"User {username} logged out")

events.subscribe("login", on_user_login)
events.subscribe("logout", on_user_logout)

events.emit("login", "Alice")
events.emit("logout", "Bob")
```

---

## 第123题：设计模式 - 装饰器模式

**问题**：实现装饰器模式（非Python装饰器）

**答案**：
```python
from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    @abstractmethod
    def operation(self):
        pass

# 具体组件
class ConcreteComponent(Component):
    def operation(self):
        return "ConcreteComponent"

# 装饰器基类
class Decorator(Component):
    def __init__(self, component):
        self._component = component

    def operation(self):
        return self._component.operation()

# 具体装饰器
class ConcreteDecoratorA(Decorator):
    def operation(self):
        return f"ConcreteDecoratorA({self._component.operation()})"

class ConcreteDecoratorB(Decorator):
    def operation(self):
        return f"ConcreteDecoratorB({self._component.operation()})"

# 使用
component = ConcreteComponent()
print(component.operation())  # ConcreteComponent

decorated = ConcreteDecoratorA(component)
print(decorated.operation())  # ConcreteDecoratorA(ConcreteComponent)

decorated = ConcreteDecoratorB(ConcreteDecoratorA(component))
print(decorated.operation())
# ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))

# 实际应用：咖啡装饰器
class Coffee(ABC):
    @abstractmethod
    def cost(self):
        pass

    @abstractmethod
    def description(self):
        pass

class SimpleCoffee(Coffee):
    def cost(self):
        return 10

    def description(self):
        return "Simple Coffee"

class CoffeeDecorator(Coffee):
    def __init__(self, coffee):
        self._coffee = coffee

class Milk(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 2

    def description(self):
        return f"{self._coffee.description()}, Milk"

class Sugar(CoffeeDecorator):
    def cost(self):
        return self._coffee.cost() + 1

    def description(self):
        return f"{self._coffee.description()}, Sugar"

# 使用
coffee = SimpleCoffee()
print(f"{coffee.description()}: ${coffee.cost()}")

coffee = Milk(coffee)
print(f"{coffee.description()}: ${coffee.cost()}")

coffee = Sugar(coffee)
print(f"{coffee.description()}: ${coffee.cost()}")
```

---

## 第124题：设计模式 - 策略模式

**问题**：实现策略模式

**答案**：
```python
from abc import ABC, abstractmethod

# 策略接口
class Strategy(ABC):
    @abstractmethod
    def execute(self, data):
        pass

# 具体策略
class ConcreteStrategyA(Strategy):
    def execute(self, data):
        return sorted(data)

class ConcreteStrategyB(Strategy):
    def execute(self, data):
        return sorted(data, reverse=True)

# 上下文
class Context:
    def __init__(self, strategy):
        self._strategy = strategy

    def set_strategy(self, strategy):
        self._strategy = strategy

    def execute_strategy(self, data):
        return self._strategy.execute(data)

# 使用
data = [3, 1, 4, 1, 5, 9]

context = Context(ConcreteStrategyA())
print(context.execute_strategy(data))  # [1, 1, 3, 4, 5, 9]

context.set_strategy(ConcreteStrategyB())
print(context.execute_strategy(data))  # [9, 5, 4, 3, 1, 1]

# 实际应用：支付策略
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number):
        self.card_number = card_number

    def pay(self, amount):
        return f"Paid ${amount} with credit card {self.card_number}"

class PayPalPayment(PaymentStrategy):
    def __init__(self, email):
        self.email = email

    def pay(self, amount):
        return f"Paid ${amount} with PayPal {self.email}"

class CryptoPayment(PaymentStrategy):
    def __init__(self, wallet_address):
        self.wallet_address = wallet_address

    def pay(self, amount):
        return f"Paid ${amount} with crypto {self.wallet_address}"

class ShoppingCart:
    def __init__(self):
        self.items = []
        self._payment_strategy = None

    def add_item(self, item, price):
        self.items.append((item, price))

    def set_payment_strategy(self, strategy):
        self._payment_strategy = strategy

    def checkout(self):
        total = sum(price for _, price in self.items)
        return self._payment_strategy.pay(total)

cart = ShoppingCart()
cart.add_item("Book", 20)
cart.add_item("Pen", 5)

cart.set_payment_strategy(CreditCardPayment("1234-5678"))
print(cart.checkout())
```

---

## 第125题：设计模式 - 建造者模式

**问题**：实现建造者模式

**答案**：
```python
# 产品类
class Computer:
    def __init__(self):
        self.cpu = None
        self.ram = None
        self.storage = None
        self.gpu = None

    def __str__(self):
        return f"Computer(CPU={self.cpu}, RAM={self.ram}, Storage={self.storage}, GPU={self.gpu})"

# 建造者
class ComputerBuilder:
    def __init__(self):
        self.computer = Computer()

    def set_cpu(self, cpu):
        self.computer.cpu = cpu
        return self

    def set_ram(self, ram):
        self.computer.ram = ram
        return self

    def set_storage(self, storage):
        self.computer.storage = storage
        return self

    def set_gpu(self, gpu):
        self.computer.gpu = gpu
        return self

    def build(self):
        return self.computer

# 使用（链式调用）
computer = (ComputerBuilder()
            .set_cpu("Intel i7")
            .set_ram("16GB")
            .set_storage("512GB SSD")
            .set_gpu("NVIDIA RTX 3080")
            .build())

print(computer)

# 导演类（可选）
class ComputerDirector:
    @staticmethod
    def build_gaming_computer(builder):
        return (builder
                .set_cpu("Intel i9")
                .set_ram("32GB")
                .set_storage("1TB SSD")
                .set_gpu("NVIDIA RTX 4090")
                .build())

    @staticmethod
    def build_office_computer(builder):
        return (builder
                .set_cpu("Intel i5")
                .set_ram("8GB")
                .set_storage("256GB SSD")
                .build())

builder = ComputerBuilder()
gaming_pc = ComputerDirector.build_gaming_computer(builder)

builder = ComputerBuilder()
office_pc = ComputerDirector.build_office_computer(builder)

# 实际应用：查询构建器
class QueryBuilder:
    def __init__(self):
        self._select = []
        self._from = None
        self._where = []
        self._order_by = None
        self._limit = None

    def select(self, *fields):
        self._select.extend(fields)
        return self

    def from_table(self, table):
        self._from = table
        return self

    def where(self, condition):
        self._where.append(condition)
        return self

    def order_by(self, field):
        self._order_by = field
        return self

    def limit(self, n):
        self._limit = n
        return self

    def build(self):
        query = f"SELECT {', '.join(self._select)}"
        query += f" FROM {self._from}"
        if self._where:
            query += f" WHERE {' AND '.join(self._where)}"
        if self._order_by:
            query += f" ORDER BY {self._order_by}"
        if self._limit:
            query += f" LIMIT {self._limit}"
        return query

query = (QueryBuilder()
         .select("name", "age")
         .from_table("users")
         .where("age > 18")
         .where("city = 'NYC'")
         .order_by("age")
         .limit(10)
         .build())

print(query)
```

---

## 第126题：类方法链式调用

**问题**：实现方法链式调用

**答案**：
```python
class Calculator:
    def __init__(self, value=0):
        self.value = value

    def add(self, n):
        self.value += n
        return self

    def subtract(self, n):
        self.value -= n
        return self

    def multiply(self, n):
        self.value *= n
        return self

    def divide(self, n):
        self.value /= n
        return self

    def result(self):
        return self.value

# 使用
calc = Calculator(10)
result = calc.add(5).multiply(2).subtract(10).divide(2).result()
print(result)  # 10

# 实际应用：字符串构建器
class StringBuilder:
    def __init__(self):
        self.parts = []

    def append(self, text):
        self.parts.append(str(text))
        return self

    def append_line(self, text):
        self.parts.append(str(text) + '\n')
        return self

    def append_format(self, format_string, *args):
        self.parts.append(format_string.format(*args))
        return self

    def clear(self):
        self.parts = []
        return self

    def build(self):
        return ''.join(self.parts)

text = (StringBuilder()
        .append("Hello, ")
        .append("World!")
        .append_line("")
        .append_format("The answer is {}", 42)
        .build())

print(text)

# 查询构建器（实际应用）
class Query:
    def __init__(self, model):
        self.model = model
        self._filters = []
        self._order = None
        self._limit = None

    def filter(self, **kwargs):
        self._filters.append(kwargs)
        return self

    def order_by(self, field):
        self._order = field
        return self

    def limit(self, n):
        self._limit = n
        return self

    def all(self):
        # 执行查询
        return f"Query: {self.model} with filters {self._filters}"

# 使用
query = (Query("User")
         .filter(age__gte=18)
         .filter(city="NYC")
         .order_by("-created_at")
         .limit(10)
         .all())
```

---

## 第127题：组合模式

**问题**：实现组合模式

**答案**：
```python
from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    @abstractmethod
    def operation(self):
        pass

    @abstractmethod
    def add(self, component):
        pass

    @abstractmethod
    def remove(self, component):
        pass

    @abstractmethod
    def get_child(self, index):
        pass

# 叶子节点
class Leaf(Component):
    def __init__(self, name):
        self.name = name

    def operation(self):
        return f"Leaf: {self.name}"

    def add(self, component):
        pass

    def remove(self, component):
        pass

    def get_child(self, index):
        return None

# 组合节点
class Composite(Component):
    def __init__(self, name):
        self.name = name
        self.children = []

    def operation(self):
        results = [f"Composite: {self.name}"]
        for child in self.children:
            results.append(child.operation())
        return '\n'.join(results)

    def add(self, component):
        self.children.append(component)

    def remove(self, component):
        self.children.remove(component)

    def get_child(self, index):
        return self.children[index]

# 使用
root = Composite("root")
branch1 = Composite("branch1")
branch2 = Composite("branch2")

leaf1 = Leaf("leaf1")
leaf2 = Leaf("leaf2")
leaf3 = Leaf("leaf3")

root.add(branch1)
root.add(branch2)
branch1.add(leaf1)
branch1.add(leaf2)
branch2.add(leaf3)

print(root.operation())

# 实际应用：文件系统
class FileSystemComponent(ABC):
    @abstractmethod
    def get_size(self):
        pass

    @abstractmethod
    def display(self, indent=0):
        pass

class File(FileSystemComponent):
    def __init__(self, name, size):
        self.name = name
        self.size = size

    def get_size(self):
        return self.size

    def display(self, indent=0):
        print(' ' * indent + f"File: {self.name} ({self.size} bytes)")

class Directory(FileSystemComponent):
    def __init__(self, name):
        self.name = name
        self.children = []

    def add(self, component):
        self.children.append(component)

    def get_size(self):
        return sum(child.get_size() for child in self.children)

    def display(self, indent=0):
        print(' ' * indent + f"Directory: {self.name}")
        for child in self.children:
            child.display(indent + 2)

# 使用
root = Directory("root")
home = Directory("home")
user = Directory("user")

file1 = File("file1.txt", 100)
file2 = File("file2.txt", 200)
file3 = File("file3.txt", 300)

root.add(home)
home.add(user)
user.add(file1)
user.add(file2)
root.add(file3)

root.display()
print(f"Total size: {root.get_size()} bytes")
```

---

## 第128题：依赖注入

**问题**：实现依赖注入

**答案**：
```python
# 不使用依赖注入（紧耦合）
class Database:
    def query(self, sql):
        return f"Executing: {sql}"

class UserService:
    def __init__(self):
        self.db = Database()  # 硬编码依赖

    def get_user(self, user_id):
        return self.db.query(f"SELECT * FROM users WHERE id = {user_id}")

# 使用依赖注入（松耦合）
class UserService:
    def __init__(self, database):
        self.db = database  # 注入依赖

    def get_user(self, user_id):
        return self.db.query(f"SELECT * FROM users WHERE id = {user_id}")

db = Database()
service = UserService(db)

# 接口依赖
from abc import ABC, abstractmethod

class DatabaseInterface(ABC):
    @abstractmethod
    def query(self, sql):
        pass

class MySQLDatabase(DatabaseInterface):
    def query(self, sql):
        return f"MySQL: {sql}"

class PostgreSQLDatabase(DatabaseInterface):
    def query(self, sql):
        return f"PostgreSQL: {sql}"

class UserService:
    def __init__(self, database: DatabaseInterface):
        self.db = database

    def get_user(self, user_id):
        return self.db.query(f"SELECT * FROM users WHERE id = {user_id}")

# 可以注入不同的实现
mysql_service = UserService(MySQLDatabase())
postgres_service = UserService(PostgreSQLDatabase())

# 依赖注入容器
class Container:
    def __init__(self):
        self._services = {}

    def register(self, name, service):
        self._services[name] = service

    def get(self, name):
        return self._services[name]

# 使用
container = Container()
container.register('database', MySQLDatabase())
container.register('user_service', UserService(container.get('database')))

service = container.get('user_service')

# 自动注入装饰器
def inject(*dependencies):
    def decorator(cls):
        original_init = cls.__init__

        def new_init(self, **kwargs):
            for dep in dependencies:
                if dep not in kwargs:
                    kwargs[dep] = container.get(dep)
            original_init(self, **kwargs)

        cls.__init__ = new_init
        return cls
    return decorator

@inject('database')
class UserService:
    def __init__(self, database):
        self.db = database
```

---

## 第129题：多态性

**问题**：理解和使用多态

**答案**：
```python
# 基本多态
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

def animal_sound(animal):
    print(animal.speak())

dog = Dog()
cat = Cat()

animal_sound(dog)  # Woof!
animal_sound(cat)  # Meow!

# 鸭子类型（Python特色）
class Duck:
    def speak(self):
        return "Quack!"

class Person:
    def speak(self):
        return "Hello!"

# 不需要继承关系，只要有speak方法
for obj in [Dog(), Cat(), Duck(), Person()]:
    animal_sound(obj)

# 运算符多态
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        elif isinstance(other, (int, float)):
            return Vector(self.x + other, self.y + other)

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)  # Vector(4, 6)
print(v1 + 5)   # Vector(6, 7)

# 方法多态
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        import math
        return math.pi * self.radius ** 2

def print_area(shape):
    print(f"Area: {shape.area()}")

shapes = [Rectangle(5, 10), Circle(7)]
for shape in shapes:
    print_area(shape)

# 接口多态
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount):
        pass

class CreditCardProcessor(PaymentProcessor):
    def process_payment(self, amount):
        return f"Processing ${amount} via credit card"

class PayPalProcessor(PaymentProcessor):
    def process_payment(self, amount):
        return f"Processing ${amount} via PayPal"

def process(processor: PaymentProcessor, amount):
    print(processor.process_payment(amount))

processors = [CreditCardProcessor(), PayPalProcessor()]
for processor in processors:
    process(processor, 100)
```

---

## 第130题：类的自省

**问题**：检查和操作类的内部信息

**答案**：
```python
class Person:
    """A person class"""
    species = "Homo sapiens"

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, I'm {self.name}"

# 获取类信息
print(Person.__name__)  # Person
print(Person.__doc__)   # A person class
print(Person.__module__)  # __main__
print(Person.__bases__)  # (<class 'object'>,)

# 获取属性
print(dir(Person))  # 所有属性和方法
print(vars(Person))  # 类的__dict__

# 检查属性
print(hasattr(Person, 'species'))  # True
print(getattr(Person, 'species'))  # Homo sapiens
setattr(Person, 'planet', 'Earth')
delattr(Person, 'planet')

# 实例自省
p = Person("Alice", 25)
print(type(p))  # <class '__main__.Person'>
print(isinstance(p, Person))  # True
print(isinstance(p, object))  # True

# 获取实例属性
print(p.__dict__)  # {'name': 'Alice', 'age': 25}
print(p.__class__)  # <class '__main__.Person'>

# 检查方法
import inspect

print(inspect.isclass(Person))  # True
print(inspect.ismethod(p.greet))  # True
print(inspect.isfunction(Person.greet))  # True

# 获取方法签名
sig = inspect.signature(Person.__init__)
print(sig)  # (self, name, age)

# 获取源代码
print(inspect.getsource(Person))

# 获取MRO
print(Person.mro())

# 动态创建属性
class DynamicPerson:
    pass

p = DynamicPerson()
p.name = "Bob"
p.age = 30

# 检查可调用
print(callable(p.name))  # False
print(callable(Person))  # True

# 获取所有方法
methods = [m for m in dir(Person) if callable(getattr(Person, m))]
print(methods)

# 类变量 vs 实例变量
p1 = Person("Alice", 25)
p2 = Person("Bob", 30)

print(p1.species)  # Homo sapiens（类变量）
Person.species = "Human"
print(p2.species)  # Human

p1.species = "Modified"
print(p1.species)  # Modified（实例变量）
print(p2.species)  # Human（类变量）
```

---

## 学习笔记

在这里记录你的学习心得和遇到的问题：

```
日期：

重点知识：
- 类的定义和实例化
- 继承和多态
- 特殊方法（魔术方法）
- 设计模式应用
- 元类和描述符

易错点：
- 类属性 vs 实例属性
- 多重继承的MRO
- __new__ vs __init__
- 可变默认参数

实践心得：
```

---

## 进度跟踪

完成题目：0/30

- [ ] 第101题 - [ ] 第102题 - [ ] 第103题 - [ ] 第104题 - [ ] 第105题
- [ ] 第106题 - [ ] 第107题 - [ ] 第108题 - [ ] 第109题 - [ ] 第110题
- [ ] 第111题 - [ ] 第112题 - [ ] 第113题 - [ ] 第114题 - [ ] 第115题
- [ ] 第116题 - [ ] 第117题 - [ ] 第118题 - [ ] 第119题 - [ ] 第120题
- [ ] 第121题 - [ ] 第122题 - [ ] 第123题 - [ ] 第124题 - [ ] 第125题
- [ ] 第126题 - [ ] 第127题 - [ ] 第128题 - [ ] 第129题 - [ ] 第130题
